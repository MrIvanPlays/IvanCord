From d8fcd9d548e61277eaee9a35a4d5f147a11fb5c1 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <pekov.ivan@abv.bg>
Date: Wed, 21 Aug 2019 21:21:33 +0300
Subject: [PATCH] Add OfflinePlayer concept


diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/connection/OfflinePlayer.java b/api/src/main/java/com/mrivanplays/ivancord/api/connection/OfflinePlayer.java
new file mode 100644
index 00000000..926f74a6
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/connection/OfflinePlayer.java
@@ -0,0 +1,52 @@
+package com.mrivanplays.ivancord.api.connection;
+
+import java.util.Optional;
+import java.util.UUID;
+
+import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+
+/**
+ * Represents a player, which is probably offline.
+ */
+public interface OfflinePlayer
+{
+
+    /**
+     * Returns the name of the player. This might be null or change in time
+     * as the name is not a key authentication for a player anymore.
+     *
+     * @return name of the offline player or null
+     */
+    String getName();
+
+    /**
+     * Returns the unique id of the player. This might be null if the player was
+     * got from the name and the Mojang servers were down.
+     *
+     * @return unique id
+     */
+    UUID getUniqueId();
+
+    /**
+     * Returns whenever this player has played before.
+     *
+     * @return <code>true</code> if played, <code>false</code> otherwise
+     */
+    boolean hasPlayedBefore();
+
+    /**
+     * Gets the specified offline player as a online player. The optional
+     * will be empty if the player is not online.
+     *
+     * @return optional of player
+     */
+    Optional<ProxiedPlayer> getPlayer();
+
+    /**
+     * Returns the last known server where the player was.
+     *
+     * @return optional of the last known server of the player
+     */
+    Optional<ServerInfo> getLastServer();
+}
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
index 25885939..4818cc16 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
@@ -8,6 +8,7 @@ import java.util.Map;
 import java.util.UUID;
 import java.util.function.BiConsumer; // IvanCord
 import java.util.logging.Logger;
+import com.mrivanplays.ivancord.api.connection.OfflinePlayer; // IvanCord
 import lombok.Getter;
 import net.md_5.bungee.api.chat.BaseComponent;
 import net.md_5.bungee.api.config.ConfigurationAdapter;
@@ -359,6 +360,24 @@ public abstract class ProxyServer
      */
     public abstract void registerOutboundPacketListener(Plugin plugin, BiConsumer<DefinedPacket, PacketDirection> packetListener);
 
+    /**
+     * Returns a {@link OfflinePlayer}, specified by his name. This method
+     * will never return null
+     *
+     * @param name the name of the player you want to get
+     * @return offline player
+     */
+    public abstract OfflinePlayer getOfflinePlayer(String name);
+
+    /**
+     * Returns a {@link OfflinePlayer}, specified by his unique id. This
+     * will never return null
+     *
+     * @param uuid the unique id of the player you want to get
+     * @return offline player
+     */
+    public abstract OfflinePlayer getOfflinePlayer(UUID uuid);
+
     // IvanCord end
 
 }
diff --git a/proxy/src/main/java/com/mrivanplays/ivancord/UUIDFetcher.java b/proxy/src/main/java/com/mrivanplays/ivancord/UUIDFetcher.java
new file mode 100644
index 00000000..45af4fcd
--- /dev/null
+++ b/proxy/src/main/java/com/mrivanplays/ivancord/UUIDFetcher.java
@@ -0,0 +1,120 @@
+package com.mrivanplays.ivancord;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Map;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import net.md_5.bungee.Util;
+
+public class UUIDFetcher
+{
+
+    private String playerName;
+    private Callback lastResult;
+
+    //
+
+    private static Map<String, UUIDFetcher> knownInstances = new ConcurrentHashMap<>();
+
+    public static UUIDFetcher createOrGet(String playerName)
+    {
+        if ( knownInstances.get( playerName ) != null )
+        {
+            return knownInstances.get( playerName );
+        } else
+        {
+            UUIDFetcher fetcher = new UUIDFetcher( playerName );
+            knownInstances.put( playerName, fetcher );
+            return fetcher;
+        }
+    }
+
+    //
+
+    private UUIDFetcher(String playerName)
+    {
+        this.playerName = playerName;
+    }
+
+    public CompletableFuture<Callback> retrieveUUID()
+    {
+        if ( lastResult != null )
+        {
+            return CompletableFuture.completedFuture( lastResult );
+        }
+        return CompletableFuture.supplyAsync( () ->
+        {
+            try
+            {
+                URL url = new URL( "https://api.mojang.com/users/profiles/minecraft/" + playerName );
+
+                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+                connection.addRequestProperty( "User-Agent", "IvanCord-UUID-Fetcher" );
+
+                InputStreamReader inputStream = new InputStreamReader( connection.getInputStream() );
+
+                JsonElement element = new JsonParser().parse( inputStream );
+                inputStream.close();
+
+                if ( !element.isJsonObject() )
+                {
+                    return new Callback( null, State.ELEMENT_NOT_JSON_OBJECT );
+                }
+                JsonObject object = element.getAsJsonObject();
+                return new Callback( get( object.get( "id" ).getAsString() ), State.SUCCESS );
+            } catch ( IOException e )
+            {
+                return new Callback( null, State.COULD_NOT_CONNECT );
+            }
+        } );
+    }
+
+    private UUID get(String id)
+    {
+        return Util.getUUID( id );
+    }
+
+    public class Callback
+    {
+
+        {
+            lastResult = this;
+        }
+
+        private Optional<UUID> uuid;
+        private State state;
+
+        public Callback(UUID uuid, State state)
+        {
+            this.uuid = Optional.ofNullable( uuid );
+            this.state = state;
+        }
+
+        public Optional<UUID> getUUID()
+        {
+            return uuid;
+        }
+
+        public State getState()
+        {
+            return state;
+        }
+    }
+
+    public enum State
+    {
+        SUCCESS,
+        ELEMENT_NOT_JSON_OBJECT,
+        COULD_NOT_CONNECT
+    }
+
+}
diff --git a/proxy/src/main/java/com/mrivanplays/ivancord/connection/BungeeOfflinePlayer.java b/proxy/src/main/java/com/mrivanplays/ivancord/connection/BungeeOfflinePlayer.java
new file mode 100644
index 00000000..4b91e441
--- /dev/null
+++ b/proxy/src/main/java/com/mrivanplays/ivancord/connection/BungeeOfflinePlayer.java
@@ -0,0 +1,44 @@
+package com.mrivanplays.ivancord.connection;
+
+import java.util.Optional;
+import java.util.UUID;
+
+import com.mrivanplays.ivancord.api.connection.OfflinePlayer;
+import lombok.AllArgsConstructor;
+import lombok.EqualsAndHashCode;
+import lombok.Getter;
+import lombok.ToString;
+import lombok.experimental.Accessors;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.config.ServerInfo;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+
+@Getter
+@ToString
+@EqualsAndHashCode
+@AllArgsConstructor
+public class BungeeOfflinePlayer implements OfflinePlayer
+{
+
+    private String name;
+    private UUID uniqueId;
+    @Accessors(fluent = true)
+    private boolean hasPlayedBefore;
+    private ServerInfo lastKnownServer;
+
+    @Override
+    public Optional<ProxiedPlayer> getPlayer()
+    {
+        return Optional.ofNullable( BungeeCord.getInstance().getPlayer( uniqueId ) );
+    }
+
+    @Override
+    public Optional<ServerInfo> getLastServer()
+    {
+        if ( getPlayer().isPresent() )
+        {
+            return Optional.of( getPlayer().get().getServer().getInfo() );
+        }
+        return Optional.ofNullable( lastKnownServer );
+    }
+}
diff --git a/proxy/src/main/java/com/mrivanplays/ivancord/connection/Playerdata.java b/proxy/src/main/java/com/mrivanplays/ivancord/connection/Playerdata.java
new file mode 100644
index 00000000..e724c64b
--- /dev/null
+++ b/proxy/src/main/java/com/mrivanplays/ivancord/connection/Playerdata.java
@@ -0,0 +1,165 @@
+package com.mrivanplays.ivancord.connection;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.mrivanplays.ivancord.UUIDFetcher;
+import com.mrivanplays.ivancord.api.connection.OfflinePlayer;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.config.ServerInfo;
+
+public class Playerdata
+{
+
+    private File file;
+    private Gson gson;
+
+    public Playerdata()
+    {
+        this.file = new File( "playerdata.json" );
+        createFile();
+        gson = new GsonBuilder().setPrettyPrinting().create();
+    }
+
+    public OfflinePlayer getOfflinePlayer(String name)
+    {
+        Optional<OfflinePlayer> search = deserialize()
+                .parallelStream()
+                .filter( player -> player.getName() != null && player.getName().equalsIgnoreCase( name ) )
+                .findFirst();
+        if ( search.isPresent() )
+        {
+            return search.get();
+        } else
+        {
+            UUIDFetcher uuidFetcher = UUIDFetcher.createOrGet( name );
+            UUIDFetcher.Callback callback = uuidFetcher.retrieveUUID().join();
+            OfflinePlayer player;
+            if ( !callback.getUUID().isPresent() )
+            {
+                player =  new BungeeOfflinePlayer( name, null, false, null );
+            } else
+            {
+                player = new BungeeOfflinePlayer( name, callback.getUUID().get(), false, null );
+            }
+            List<OfflinePlayer> known = new ArrayList<>( deserialize() );
+            known.add( player );
+            serialize( known );
+            return player;
+        }
+    }
+
+    public OfflinePlayer getOfflinePlayer(UUID uuid)
+    {
+        Optional<OfflinePlayer> search = deserialize()
+                .parallelStream()
+                .filter( player -> player.getUniqueId().equals( uuid ) )
+                .findFirst();
+        if ( search.isPresent() )
+        {
+            return search.get();
+        } else
+        {
+            OfflinePlayer player = new BungeeOfflinePlayer( null, uuid, false, null );
+            List<OfflinePlayer> known = new ArrayList<>( deserialize() );
+            known.add( player );
+            serialize( known );
+            return player;
+        }
+    }
+
+    private void serialize(List<OfflinePlayer> players)
+    {
+        file.delete();
+        createFile();
+        try ( Writer writer = new OutputStreamWriter( new FileOutputStream( file ) ) )
+        {
+            JsonArray array = new JsonArray();
+            for ( OfflinePlayer player : players )
+            {
+                JsonObject object = new JsonObject();
+                if ( player.getName() != null )
+                {
+                    object.addProperty( "name", player.getName() );
+                }
+                object.addProperty( "uuid", player.getUniqueId().toString() );
+                if ( player.getLastServer().isPresent() )
+                {
+                    object.addProperty( "lastKnownServer", player.getLastServer().get().getName() );
+                }
+                array.add( object );
+            }
+            gson.toJson( array, writer );
+        } catch ( IOException ignored )
+        {
+        }
+    }
+
+    private List<OfflinePlayer> deserialize()
+    {
+        List<OfflinePlayer> list = new ArrayList<>();
+        try ( Reader reader = new InputStreamReader( new FileInputStream( file ) ) )
+        {
+            JsonArray array = gson.fromJson( reader, JsonArray.class );
+            if ( array == null || array.size() == 0 )
+            {
+                return list;
+            }
+            for ( JsonElement element : array )
+            {
+                if ( !element.isJsonObject() )
+                {
+                    continue;
+                }
+                JsonObject object = element.getAsJsonObject();
+                UUID uniqueId = UUID.fromString( object.get( "uuid" ).getAsString() );
+                String name = null;
+                if ( object.has( "name" ) )
+                {
+                    name = object.get( "name" ).getAsString();
+                }
+                ServerInfo lastKnownServer = null;
+                if ( object.has( "lastKnownServer" ) )
+                {
+                    lastKnownServer = BungeeCord.getInstance().getServerInfo( object.get( "lastKnownServer" ).getAsString() );
+                }
+                list.add( new BungeeOfflinePlayer( name, uniqueId, true, lastKnownServer ) );
+            }
+        } catch ( IOException ignored )
+        {
+        }
+        return list;
+    }
+
+    private void createFile()
+    {
+        if ( !file.exists() )
+        {
+            if ( !file.getParentFile().exists() )
+            {
+                file.getParentFile().mkdirs();
+            }
+            try
+            {
+                file.createNewFile();
+            } catch ( IOException ignored )
+            {
+            }
+        }
+    }
+}
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index 0ed98286..178d5de3 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -118,6 +118,8 @@ import com.mrivanplays.ivancord.api.plugin.ServicesManager;
 import com.mrivanplays.ivancord.api.command.IvanCordCommandManager;
 import com.mrivanplays.ivancord.protocol.PacketListener;
 import com.mrivanplays.ivancord.api.PacketDirection;
+import com.mrivanplays.ivancord.api.connection.OfflinePlayer;
+import com.mrivanplays.ivancord.connection.Playerdata;
 // IvanCord end
 
 /**
@@ -213,6 +215,7 @@ public class BungeeCord extends ProxyServer
                     .setNameFormat( "PacketListener Executor/#%d" )
                     .build()
     );
+    private Playerdata playerdata = new Playerdata();
     // IvanCord end
 
     {
@@ -873,5 +876,17 @@ public class BungeeCord extends ProxyServer
             }
         } );
     }
+
+    @Override
+    public OfflinePlayer getOfflinePlayer(String name)
+    {
+        return playerdata.getOfflinePlayer( name );
+    }
+
+    @Override
+    public OfflinePlayer getOfflinePlayer(UUID uuid)
+    {
+        return playerdata.getOfflinePlayer( uuid );
+    }
     // IvanCord end
 }
-- 
2.23.0.windows.1

