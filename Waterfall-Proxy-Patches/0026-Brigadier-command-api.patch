From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ivan Pekov <ivan@mrivanplays.com>
Date: Thu, 3 Sep 2020 16:11:03 +0300
Subject: [PATCH] Brigadier command api


diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..158fef8dbd9e616c2bfebbfecde662bca22390be
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java
@@ -0,0 +1,46 @@
+package com.mrivanplays.ivancord.api.command;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.TabExecutor;
+
+class Brigadier2LegacyCommandTransformer
+{
+
+    static Command transform(CommandDispatcherProxy dispatcher, BrigadierCommand command)
+    {
+        return new DummyCommand( dispatcher, command );
+    }
+
+    private static class DummyCommand extends Command implements TabExecutor
+    {
+
+        private final CommandDispatcherProxy dispatcher;
+        private final BrigadierCommand command;
+
+        public DummyCommand(CommandDispatcherProxy dispatcher, BrigadierCommand command)
+        {
+            super( command.getCommandNode().getName(), null, command.getAliases() );
+            this.dispatcher = dispatcher;
+            this.command = command;
+        }
+
+        @Override
+        public void execute(CommandSender sender, String alias, String[] args)
+        {
+            dispatcher.dispatch( sender, alias + String.join( " ", args ) );
+        }
+
+        @Override
+        public boolean hasPermission(CommandSender sender)
+        {
+            return command.getCommandNode().getRequirement() == null || command.getCommandNode().getRequirement().test( sender );
+        }
+
+        @Override
+        public Iterable<String> onTabComplete(CommandSender sender, String alias, String[] args)
+        {
+            return dispatcher.complete( sender, alias + String.join( " ", args ), false );
+        }
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c4769518b0e957b5365983434adcfca81dc51115
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java
@@ -0,0 +1,43 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Preconditions;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.Setter;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Plugin;
+
+@RequiredArgsConstructor
+@AllArgsConstructor
+@Getter
+@Setter
+public final class BrigadierCommand
+{
+
+    /**
+     * A special return value saying to forward the command to the server.
+     */
+    public static int FORWARD = 0xF448224;
+
+    private final Plugin plugin;
+    @NonNull
+    private final LiteralCommandNode<CommandSender> commandNode;
+    private String[] aliases = null;
+
+    public BrigadierCommand(Plugin plugin, LiteralArgumentBuilder<CommandSender> argumentBuilder)
+    {
+        Preconditions.checkNotNull( argumentBuilder, "argumentBuilder" );
+        this.plugin = plugin;
+        this.commandNode = argumentBuilder.build();
+    }
+
+    public BrigadierCommand(Plugin plugin, LiteralArgumentBuilder<CommandSender> argumentBuilder, String... aliases)
+    {
+        this( plugin, argumentBuilder );
+        this.aliases = aliases;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java
new file mode 100644
index 0000000000000000000000000000000000000000..3668ab3e1f96189b78501855315230b9a82a2575
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java
@@ -0,0 +1,540 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Table;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.ParseResults;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestion;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import com.mrivanplays.ivancord.api.command.arguments.BungeeProtoPlayerProvider;
+import com.mrivanplays.ivancord.api.command.message.BungeeMessage;
+import com.mrivanplays.ivancord.api.util.Constants;
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent;
+import io.github.waterfallmc.waterfall.exception.ProxyCommandException;
+import io.github.waterfallmc.waterfall.exception.ProxyTabCompleteException;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.api.plugin.PluginManager;
+
+public final class CommandDispatcherProxy
+{
+
+    private final PluginManager pluginManager;
+    private final ProxyServer proxy; // easier access
+
+    private final CommandDispatcher<CommandSender> dispatcher = new CommandDispatcher<>();
+    private final Table<String, String, Command> commandsTable = HashBasedTable.create();
+    private final Lock commandsLock = new ReentrantLock();
+
+    private Collection<Map.Entry<String, Command>> cachedCommands;
+
+    public CommandDispatcherProxy(PluginManager pluginManager, ProxyServer proxy)
+    {
+        this.pluginManager = pluginManager;
+        this.proxy = proxy;
+        BungeeProtoPlayerProvider.initialize( proxy );
+    }
+
+    public void register(Plugin plugin, Command command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        register( Legacy2BrigadierCommandTransformer.transform( plugin, command ), command );
+    }
+
+    private void register(BrigadierCommand brigadierCommand, Command bungeeCommand)
+    {
+        CommandNode<CommandSender> base = brigadierCommand.getCommandNode();
+        dispatcher.getRoot().addChild( base );
+        String main;
+        if ( brigadierCommand.getPlugin() == null )
+        {
+            main = "BungeeSpecificCommand";
+        } else
+        {
+            main = brigadierCommand.getPlugin().getDescription().getMain();
+        }
+        commandsLock.lock();
+        try
+        {
+            commandsTable.put( main, base.getName().toLowerCase(), bungeeCommand );
+            if ( brigadierCommand.getAliases() != null && brigadierCommand.getAliases().length != 0 )
+            {
+                for ( String alias : brigadierCommand.getAliases() )
+                {
+                    alias = alias.toLowerCase();
+                    // using .redirect doesn't work properly
+                    // see https://github.com/Mojang/brigadier/issues/46
+                    LiteralCommandNode<CommandSender> redirect = LiteralArgumentBuilder.<CommandSender>literal( alias )
+                        .requires( base.getRequirement() )
+                        .forward( base.getRedirect(), base.getRedirectModifier(), base.isFork() )
+                        .executes( base.getCommand() )
+                        .build();
+                    for ( CommandNode<CommandSender> child : base.getChildren() )
+                    {
+                        redirect.addChild( child );
+                    }
+                    dispatcher.getRoot().addChild( redirect );
+                    commandsTable.put( main, alias, bungeeCommand );
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public void register(BrigadierCommand command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        register( command, Brigadier2LegacyCommandTransformer.transform( this, command ) );
+    }
+
+    public void unregister(Command command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        String nameLower = command.getName().toLowerCase();
+        commandsLock.lock();
+        try
+        {
+            for ( Plugin plugin : pluginManager.getPlugins() )
+            {
+                String main = plugin.getDescription().getMain();
+                if ( commandsTable.containsRow( main ) )
+                {
+                    Map<String, Command> commands = commandsTable.row( main );
+                    if ( commands.containsKey( nameLower ) || containsAny( commands, command.getAliases() ) )
+                    {
+                        CommandNode<CommandSender> node = dispatcher.getRoot().getChild( nameLower );
+                        if ( node != null )
+                        {
+                            commandsTable.remove( main, nameLower );
+                            dispatcher.getRoot().getChildren().remove( node );
+                            if ( command.getAliases() != null && command.getAliases().length != 0 )
+                            {
+                                for ( String alias : command.getAliases() )
+                                {
+                                    alias = alias.toLowerCase();
+                                    CommandNode<CommandSender> aliasNode = dispatcher.getRoot().getChild( alias );
+                                    if ( aliasNode != null )
+                                    {
+                                        commandsTable.remove( main, alias );
+                                        dispatcher.getRoot().getChildren().remove( aliasNode );
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    private boolean containsAny(Map<String, Command> col, String[] array)
+    {
+        if ( array == null || array.length == 0 )
+        {
+            return false;
+        }
+        for ( String s : array )
+        {
+            if ( col.containsKey( s.toLowerCase() ) )
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isExecutable(String commandName, CommandSender sender)
+    {
+        if ( commandName == null || commandName.isEmpty() )
+        {
+            return false;
+        }
+        Preconditions.checkNotNull( sender, "sender" );
+        commandName = commandName.toLowerCase();
+        if ( dispatcher.getRoot().getChild( commandName ) != null )
+        {
+            return !( sender instanceof ProxiedPlayer ) || proxy.getDisabledCommands() == null ||  !proxy.getDisabledCommands().contains( commandName );
+        }
+        return false;
+    }
+
+    public void unregister(BrigadierCommand command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        dispatcher.getRoot().getChildren().remove( command.getCommandNode() );
+        commandsLock.lock();
+        try
+        {
+            String main;
+            if ( command.getPlugin() == null )
+            {
+                main = "BungeeSpecificCommand";
+            } else
+            {
+                main = command.getPlugin().getDescription().getMain();
+            }
+            commandsTable.remove( main, command.getCommandNode().getName().toLowerCase() );
+            if ( command.getAliases() != null && command.getAliases().length != 0 )
+            {
+                for ( String alias : command.getAliases() )
+                {
+                    alias = alias.toLowerCase();
+                    CommandNode<CommandSender> node = dispatcher.getRoot().getChild( alias );
+                    if ( node != null )
+                    {
+                        dispatcher.getRoot().getChildren().remove( node );
+                        commandsTable.remove( main, alias );
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    public void unregisterAll(Plugin plugin)
+    {
+        String main;
+        if ( plugin == null )
+        {
+            main = "BungeeSpecificCommand";
+        } else
+        {
+            main = plugin.getDescription().getMain();
+        }
+        commandsLock.lock();
+        try
+        {
+            Map<String, Command> commands = commandsTable.rowMap().remove( main );
+            if ( commands != null )
+            {
+                for ( String alias : commands.keySet() )
+                {
+                    CommandNode<CommandSender> node = dispatcher.getRoot().getChild( alias.toLowerCase() );
+                    if ( node != null )
+                    {
+                        dispatcher.getRoot().getChildren().remove( node );
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    public int dispatch(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() )
+        {
+            return 0;
+        }
+        String commandName;
+        if ( input.indexOf( ' ' ) == -1 )
+        {
+            commandName = input.toLowerCase( Locale.ROOT );
+        } else
+        {
+            commandName = input.substring( 0, input.indexOf( ' ' ) );
+        }
+        if ( !isExecutable( commandName, sender ) )
+        {
+            return 0;
+        }
+        try
+        {
+            int result = dispatcher.execute( input, sender );
+            if ( result == BrigadierCommand.FORWARD )
+            {
+                // that's of course, a lie for the dispatchCommand's return value
+                // but we can't just break bungee api so im sorry for lying :(
+                return 0;
+            }
+            return 1;
+        } catch ( CommandSyntaxException e )
+        {
+            if ( sender instanceof ProxiedPlayer )
+            {
+                CommandNode<CommandSender> node = dispatcher.getRoot().getChild( commandName.toLowerCase() );
+                Command legacyCommand = getCommand( commandName.toLowerCase() );
+                if ( node != null && node.getRequirement() != null )
+                {
+                    try
+                    {
+                        if ( !node.getRequirement().test( sender ) )
+                        {
+                            sender.sendMessage( TextComponent.fromLegacyText( legacyCommand.getPermissionMessage() != null ? legacyCommand.getPermissionMessage() : proxy.getTranslation( "no_permission" ) ) );
+                            return 2;
+                        }
+                    } catch ( Throwable e1 )
+                    {
+                        // plugins make me cry
+                        sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_executing" ) ) );
+                        proxy.getLogger().log( Level.WARNING, "Requirement test for command node " + node.getName() + " encountered an exception", e1 );
+
+                        String[] args = Constants.EMPTY_ARRAY;
+                        if ( input.indexOf( ' ' ) != -1 )
+                        {
+                            String[] inputSplit = input.split( " " );
+                            args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                        }
+                        pluginManager.callEvent( new ProxyExceptionEvent( new ProxyCommandException( e1, legacyCommand, sender, args ) ) );
+                        return 2;
+                    }
+                }
+            }
+            sender.sendMessage( BungeeMessage.convertSyntaxException( e ) );
+            return 2;
+        } catch ( Throwable e )
+        {
+            handleError( sender, e, input, commandName, true );
+            return 1;
+        }
+    }
+
+    private void handleError(CommandSender sender, Throwable e, String input, String commandName, boolean dispatchingError)
+    {
+        // plugins being plugins
+        String translation;
+        String errorMessage;
+        if ( dispatchingError )
+        {
+            translation = "internal_error_executing";
+            errorMessage = "Error in dispatching command";
+        } else
+        {
+            translation = "internal_error_completing";
+            errorMessage = "Error in completing command";
+        }
+        sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( translation ) ) );
+        proxy.getLogger().log( Level.WARNING, errorMessage, e );
+
+        String[] args = Constants.EMPTY_ARRAY;
+        if ( input.indexOf( ' ' ) != -1 )
+        {
+            String[] inputSplit = input.split( " " );
+            args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+        }
+        Command command = getCommand( commandName );
+        pluginManager.callEvent( new ProxyExceptionEvent( new ProxyCommandException( e, command, sender, args ) ) );
+    }
+
+    public Command getCommand(String commandName)
+    {
+        Preconditions.checkNotNull( commandName, "commandName" );
+        commandName = commandName.toLowerCase();
+        commandsLock.lock();
+        try
+        {
+            for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+            {
+                if ( cell.getColumnKey() != null && cell.getColumnKey().equalsIgnoreCase( commandName ) )
+                {
+                    return cell.getValue();
+                }
+            }
+            return null;
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public List<String> complete(CommandSender sender, String input, boolean check)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        String commandName = null;
+        if ( check )
+        {
+            if ( input == null || input.isEmpty() )
+            {
+                return Collections.emptyList();
+            }
+            if ( input.indexOf( ' ' ) == -1 )
+            {
+                commandName = input.toLowerCase( Locale.ROOT );
+            } else
+            {
+                commandName = input.substring( 0, input.indexOf( ' ' ) );
+            }
+            if ( !isExecutable( commandName, sender ) )
+            {
+                return Collections.emptyList();
+            }
+        }
+        try
+        {
+            ParseResults<CommandSender> results = dispatcher.parse( input, sender );
+            return dispatcher.getCompletionSuggestions( results )
+                .thenApply( suggestions -> Lists.transform( suggestions.getList(), Suggestion::getText ) ).join();
+        } catch ( Throwable e )
+        {
+            // plugins being plugins
+            sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_completing" ) ) );
+            proxy.getLogger().log( Level.WARNING, "Error in completing command", e );
+            String[] args = Constants.EMPTY_ARRAY;
+            if ( input.indexOf( ' ' ) != -1 )
+            {
+                String[] inputSplit = input.split( " " );
+                if ( commandName == null )
+                {
+                    commandName = inputSplit[0].toLowerCase( Locale.ROOT );
+                }
+                args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+            } else
+            {
+                if ( commandName == null )
+                {
+                    commandName = input.toLowerCase( Locale.ROOT );
+                }
+            }
+            Command command = getCommand( commandName );
+            pluginManager.callEvent( new ProxyExceptionEvent( new ProxyTabCompleteException( e, command, sender, args ) ) );
+            return Collections.emptyList();
+        }
+    }
+
+    public CompletableFuture<Suggestions> complete(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() )
+        {
+            return Suggestions.empty();
+        }
+        String commandName;
+        if ( input.indexOf( ' ' ) == -1 )
+        {
+            commandName = input.toLowerCase( Locale.ROOT );
+        } else
+        {
+            commandName = input.substring( 0, input.indexOf( ' ' ) ).toLowerCase( Locale.ROOT );
+        }
+        if ( !isExecutable( commandName, sender ) )
+        {
+            return Suggestions.empty();
+        }
+        try
+        {
+            ParseResults<CommandSender> results = dispatcher.parse( input, sender );
+            return dispatcher.getCompletionSuggestions( results );
+        } catch ( Throwable e )
+        {
+            handleError( sender, e, input, commandName, false );
+            return Suggestions.empty();
+        }
+    }
+
+    public List<String> completeWithNames(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() )
+        {
+            return Collections.emptyList();
+        }
+        if ( input.indexOf( ' ' ) == -1 && !isExecutable( input, sender ) )
+        {
+            return Collections.emptyList();
+        } else if ( input.indexOf( ' ' ) != -1 )
+        {
+            if ( !isExecutable( input.substring( 0, input.indexOf( ' ' ) ), sender ) )
+            {
+                return Collections.emptyList();
+            }
+        }
+        List<String> ret = new ArrayList<>();
+        if ( input.indexOf( ' ' ) == -1 )
+        {
+            input = input.toLowerCase();
+            commandsLock.lock();
+            try
+            {
+                for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+                {
+                    String name = cell.getColumnKey();
+                    if ( name != null )
+                    {
+                        name = name.toLowerCase();
+                        CommandNode<CommandSender> brigadierNode = dispatcher.getRoot().getChild( name );
+                        if ( brigadierNode != null && isExecutable( name, sender ) && input.startsWith( name ) )
+                        {
+                            if ( brigadierNode.getRequirement() == null || brigadierNode.getRequirement().test( sender ) )
+                            {
+                                ret.add( name );
+                            }
+                        }
+                    }
+                }
+            } finally
+            {
+                commandsLock.unlock();
+            }
+        } else
+        {
+            ret.addAll( complete( sender, input, false ) );
+        }
+        return ret;
+    }
+
+    public Collection<Map.Entry<String, Command>> getCommands()
+    {
+        if ( cachedCommands != null )
+        {
+            return Collections.unmodifiableCollection( cachedCommands );
+        }
+        commandsLock.lock();
+        try
+        {
+            Collection<Map.Entry<String, Command>> col = new ArrayList<>();
+            for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+            {
+                if ( cell.getColumnKey() != null && cell.getValue() != null )
+                {
+                    col.add( new AbstractMap.SimpleEntry<>( cell.getColumnKey(), cell.getValue() ) );
+                }
+            }
+            cachedCommands = col;
+            return Collections.unmodifiableCollection( col );
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public Collection<CommandNode<CommandSender>> getBrigadierCommands()
+    {
+        return Collections.unmodifiableCollection( dispatcher.getRoot().getChildren() );
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c358613703df96101810aee906556c27d65d1358
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java
@@ -0,0 +1,77 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Splitter;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.function.Predicate;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.api.plugin.TabExecutor;
+
+class Legacy2BrigadierCommandTransformer
+{
+
+    static final Splitter SPACE_SPLITTER = Splitter.on( ' ' );
+
+    static BrigadierCommand transform(Plugin plugin, Command command)
+    {
+        Predicate<CommandSender> requirement = command::hasPermission;
+        com.mojang.brigadier.Command<CommandSender> executes = ( context ) ->
+        {
+            String input = context.getInput();
+            if ( input.indexOf( ' ' ) == -1 )
+            {
+                command.execute( context.getSource(), input.replace( "/", "" ), new String[0] );
+            } else
+            {
+                String[] inputSplit = input.split( " " );
+                String alias = inputSplit[0].replace( "/", "" );
+                String[] args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                command.execute( context.getSource(), alias, args );
+            }
+            // returning single success is of course, a lie
+            // but that's the nature of bungee's command api...
+            return 1;
+        };
+        SuggestionProvider<CommandSender> suggests = ( context, builder ) ->
+        {
+            if ( command instanceof TabExecutor )
+            {
+                String[] inputSplit = SPACE_SPLITTER.splitToList( builder.getInput() ).toArray( new String[0] );
+                String alias = inputSplit[0].replace( "/", "" );
+                String[] args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                Iterable<String> results = ( (TabExecutor) command ).onTabComplete( context.getSource(), alias, args );
+
+                if ( results != null )
+                {
+                    Iterator<String> iterator = results.iterator();
+                    if ( !iterator.hasNext() )
+                    {
+                        return builder.buildFuture();
+                    }
+                    while ( iterator.hasNext() )
+                    {
+                        builder.suggest( iterator.next() );
+                    }
+                }
+            }
+            return builder.buildFuture();
+        };
+        LiteralCommandNode<CommandSender> base = LiteralArgumentBuilder.<CommandSender>literal( command.getName() )
+            .requires( requirement )
+            .executes( executes )
+            .then( RequiredArgumentBuilder.<CommandSender, String>argument( "args", StringArgumentType.greedyString() )
+                .requires( requirement )
+                .suggests( suggests )
+                .executes( executes )
+            ).build();
+
+        return new BrigadierCommand( plugin, base, command.getAliases() );
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/arguments/BungeeProtoPlayerProvider.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/arguments/BungeeProtoPlayerProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad08872260816e016cefabbf1b81c4757c7a0f90
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/arguments/BungeeProtoPlayerProvider.java
@@ -0,0 +1,95 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import com.mrivanplays.ivancord.api.util.Either;
+import java.util.List;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+
+public final class BungeeProtoPlayerProvider implements ProtoPlayerProvider
+{
+    
+    public static void initialize(ProxyServer proxy)
+    {
+        ProtoPlayerProviderI.set( new BungeeProtoPlayerProvider( proxy ) );
+    }
+    
+    private final ProxyServer proxy;
+    
+    private BungeeProtoPlayerProvider(ProxyServer proxy)
+    {
+        this.proxy = proxy;
+    }
+
+    @Override
+    public PlayerArgument.ProtoPlayer getProtoPlayer(String nameOrUUID)
+    {
+        try
+        {
+            ProxiedPlayer byUUID = proxy.getPlayer( UUID.fromString( nameOrUUID ) );
+            if ( byUUID == null )
+            {
+                return null;
+            }
+            return new PlayerArgument.ProtoPlayer( new Either<>( null, byUUID.getUniqueId() ) );
+        } catch ( IllegalArgumentException e )
+        {
+            ProxiedPlayer byName = proxy.getPlayer( nameOrUUID );
+            if ( byName == null )
+            {
+                return null;
+            }
+            return new PlayerArgument.ProtoPlayer( new Either<>( byName.getName(), null ) );
+        }
+    }
+
+    @Override
+    public double distanceToSq(PlayerArgument.ProtoPlayer protoPlayer1, PlayerArgument.ProtoPlayer protoPlayer2)
+    {
+        ProxiedPlayer player1 = getPlayer( protoPlayer1 );
+        ProxiedPlayer player2 = getPlayer( protoPlayer2 );
+        double x = player1.getPosition().getX() - player2.getPosition().getX();
+        double y = player1.getPosition().getY() - player2.getPosition().getY();
+        double z = player1.getPosition().getZ() - player2.getPosition().getZ();
+
+        return x * x + y * y + z * z;
+    }
+
+    private ProxiedPlayer getPlayer(PlayerArgument.ProtoPlayer protoPlayer)
+    {
+        Either<String, UUID> either = protoPlayer.getNameOrUUID();
+        switch ( either.getPresentDirection() )
+        {
+            case LEFT:
+                return proxy.getPlayer( either.getLeft().get() );
+            case RIGHT:
+                return proxy.getPlayer( either.getRight().get() );
+            case NONE:
+                return null;
+            default:
+                throw new RuntimeException( "Invalid Either#PresentDirection: " + either.getPresentDirection() );
+        }
+    }
+
+    @Override
+    public List<PlayerArgument.ProtoPlayer> players()
+    {
+        return proxy.getPlayers()
+            .stream()
+            .map( player ->
+                new PlayerArgument.ProtoPlayer(
+                    new Either<>( player.getName(), player.getUniqueId() )
+                ) )
+            .collect( Collectors.toList() );
+    }
+
+    @Override
+    public List<String> getPlayersByName()
+    {
+        return proxy.getPlayers()
+            .stream()
+            .map( ProxiedPlayer::getName )
+            .collect( Collectors.toList() );
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a4f5cf87da15e57db5526fa5fa0eed6cb018e56
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java
@@ -0,0 +1,25 @@
+package com.mrivanplays.ivancord.api.event;
+
+import com.mojang.brigadier.suggestion.Suggestions;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.api.connection.Connection;
+import net.md_5.bungee.api.event.TargetedEvent;
+import net.md_5.bungee.api.plugin.Cancellable;
+
+@Getter
+@Setter
+public class BrigadierSuggestionsEvent extends TargetedEvent implements Cancellable
+{
+
+    private boolean cancelled = false;
+    private final String cursor;
+    private Suggestions suggestions;
+
+    public BrigadierSuggestionsEvent(Connection sender, Connection receiver, String cursor, Suggestions suggestions)
+    {
+        super( sender, receiver );
+        this.cursor = cursor;
+        this.suggestions = suggestions;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fc5dc47aacbef26e12902e1f4c668ab4372008f
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java
@@ -0,0 +1,23 @@
+package com.mrivanplays.ivancord.api.event;
+
+import com.mojang.brigadier.suggestion.Suggestions;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.api.connection.Connection;
+import net.md_5.bungee.api.event.TargetedEvent;
+import net.md_5.bungee.api.plugin.Cancellable;
+
+@Getter
+@Setter
+public class BrigadierSuggestionsResponseEvent extends TargetedEvent implements Cancellable
+{
+
+    private boolean cancelled = false;
+    private Suggestions suggestions;
+
+    public BrigadierSuggestionsResponseEvent(Connection sender, Connection receiver, Suggestions suggestions)
+    {
+        super( sender, receiver );
+        this.suggestions = suggestions;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java b/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf484b95c9aea0ee9fe15714941d6fc561852459
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java
@@ -0,0 +1,7 @@
+package com.mrivanplays.ivancord.api.util;
+
+public final class Constants
+{
+
+    public static final String[] EMPTY_ARRAY = new String[0];
+}
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
index 0a182becd4b499772377d0fb87af9740363ae121..0a286a9dbd597bcac862b52401bbf1670011021a 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
@@ -409,6 +409,14 @@ public abstract class ProxyServer
      */
     public abstract Collection<com.mrivanplays.ivancord.api.connection.OfflinePlayer> getOfflinePlayers();
 
+    /**
+     * Returns a {@link ProxiedPlayer} from a {@link com.mrivanplays.ivancord.api.command.arguments.PlayerArgument.ProtoPlayer}
+     *
+     * @param protoPlayer proto player
+     * @return a player, or null if not present
+     */
+    public abstract ProxiedPlayer getPlayerFromProto(com.mrivanplays.ivancord.api.command.arguments.PlayerArgument.ProtoPlayer protoPlayer);
+
     // IvanCord end
 
 }
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
index ad096e6575ef1798346f191f41e1e9fec295d954..7ea5d8f345d768a7174e993a124b27339a3f17c0 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
@@ -7,6 +7,12 @@ import com.google.common.eventbus.Subscribe;
 import com.google.common.graph.GraphBuilder;
 import com.google.common.graph.Graphs;
 import com.google.common.graph.MutableGraph;
+// IvanCord start
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mrivanplays.ivancord.api.command.BrigadierCommand;
+import com.mrivanplays.ivancord.api.command.CommandDispatcherProxy;
+// IvanCord end
 import java.io.File;
 import java.io.InputStream;
 import java.lang.reflect.Method;
@@ -64,9 +70,10 @@ public final class PluginManager
     private final Map<String, Plugin> plugins = new LinkedHashMap<>();
     private final MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
     private final LibraryLoader libraryLoader;
-    private final Map<String, Command> commandMap = new HashMap<>();
+    //private final Map<String, Command> commandMap = new HashMap<>(); // IvanCord
+    private final CommandDispatcherProxy commandDispatcher; // IvanCord
     private Map<String, PluginDescription> toLoad = new HashMap<>();
-    private final Multimap<Plugin, Command> commandsByPlugin = ArrayListMultimap.create();
+    //private final Multimap<Plugin, Command> commandsByPlugin = ArrayListMultimap.create(); // IvanCord
     private final Multimap<Plugin, Listener> listenersByPlugin = ArrayListMultimap.create();
 
     @SuppressWarnings("unchecked")
@@ -93,6 +100,7 @@ public final class PluginManager
             proxy.getLogger().warning( "Could not initialize LibraryLoader (missing dependencies?)" );
         }
         this.libraryLoader = libraryLoader;
+        commandDispatcher = new CommandDispatcherProxy( this, proxy ); // IvanCord
     }
 
     /**
@@ -103,13 +111,29 @@ public final class PluginManager
      */
     public void registerCommand(Plugin plugin, Command command)
     {
+        /* // IvanCord start
         commandMap.put( command.getName().toLowerCase( Locale.ROOT ), command );
         for ( String alias : command.getAliases() )
         {
             commandMap.put( alias.toLowerCase( Locale.ROOT ), command );
         }
         commandsByPlugin.put( plugin, command );
+         */
+        commandDispatcher.register( plugin, command );
+        // IvanCord end
+    }
+
+    // IvanCord start - BrigadierCommand API
+    public void registerCommand(BrigadierCommand command)
+    {
+        commandDispatcher.register( command );
+    }
+
+    public void unregisterCommand(BrigadierCommand command)
+    {
+        commandDispatcher.unregister( command );
     }
+    // IvanCord end
 
     /**
      * Unregister a command so it will no longer be executed.
@@ -118,8 +142,12 @@ public final class PluginManager
      */
     public void unregisterCommand(Command command)
     {
+        /* // IvanCord start
         while ( commandMap.values().remove( command ) );
         commandsByPlugin.values().remove( command );
+         */
+        commandDispatcher.unregister( command );
+        // IvanCord end
     }
 
     /**
@@ -129,14 +157,20 @@ public final class PluginManager
      */
     public void unregisterCommands(Plugin plugin)
     {
+        /* // IvanCord start
         for ( Iterator<Command> it = commandsByPlugin.get( plugin ).iterator(); it.hasNext(); )
         {
             Command command = it.next();
             while ( commandMap.values().remove( command ) );
             it.remove();
         }
+         */
+        commandDispatcher.unregisterAll( plugin );
+        // IvanCord end
     }
 
+    // IvanCord start - comment this
+    /*
     private Command getCommandIfEnabled(String commandName, CommandSender sender)
     {
         String commandLower = commandName.toLowerCase( Locale.ROOT );
@@ -149,6 +183,8 @@ public final class PluginManager
 
         return commandMap.get( commandLower );
     }
+     */
+    // IvanCord end
 
     /**
      * Checks if the command is registered and can possibly be executed by the
@@ -160,9 +196,25 @@ public final class PluginManager
      */
     public boolean isExecutableCommand(String commandName, CommandSender sender)
     {
-        return getCommandIfEnabled( commandName, sender ) != null;
+        return commandDispatcher.isExecutable( commandName, sender ); // IvanCord
     }
 
+    // IvanCord start
+
+    /**
+     * Retrieves command in a legacy form by the name/alias specified.
+     *
+     * @param name command name/alias
+     * @return command or null
+     * @deprecated internal use only in order to support waterfall's ProxyDefineCommandsEvent
+     */
+    @Deprecated
+    public Command getCommand(String name)
+    {
+        return commandDispatcher.getCommand( name.toLowerCase() );
+    }
+    // IvanCord end
+
     public boolean dispatchCommand(CommandSender sender, String commandLine)
     {
         return dispatchCommand( sender, commandLine, null );
@@ -181,6 +233,47 @@ public final class PluginManager
      */
     public boolean dispatchCommand(CommandSender sender, String commandLine, List<String> tabResults)
     {
+        // IvanCord start - replace this whoooooooooooooooooooole stuff
+        if ( tabResults == null )
+        {
+            int result = commandDispatcher.dispatch( sender, commandLine );
+            if ( result == 1 )
+            {
+                if ( proxy.getConfig().isLogCommands() )
+                {
+                    proxy.getLogger().log( Level.INFO, "{0} executed command /{1}", new Object[]
+                    {
+                        sender.getName(), commandLine
+                    } );
+                }
+                return true;
+            } else
+            {
+                return result == 2;
+            }
+        } else
+        {
+            // due to latest BungeeCord fix we have to check some stuff here for < 1.13 completions
+            if ( commandLine == null || commandLine.isEmpty() )
+            {
+                return false;
+            }
+            String commandName;
+            if ( commandLine.indexOf( ' ' ) == -1 )
+            {
+                commandName = commandLine.toLowerCase( Locale.ROOT );
+            } else
+            {
+                commandName = commandLine.substring( 0, commandLine.indexOf( ' ' ) );
+            }
+            if ( !commandDispatcher.isExecutable( commandName, sender ) )
+            {
+                return false;
+            }
+            tabResults.addAll( commandDispatcher.complete( sender, commandLine, false ) );
+            return true;
+        }
+        /*
         String[] split = commandLine.split( " ", -1 );
         // Check for chat that only contains " "
         if ( split.length == 0 || split[0].isEmpty() )
@@ -238,6 +331,7 @@ public final class PluginManager
         // Waterfall end
             }
         return true;
+         */ // IvanCord end
     }
 
     // Waterfall start - Add method to tab-complete command names
@@ -253,6 +347,9 @@ public final class PluginManager
      * @return The tab-complete suggestions
      */
     public List<String> tabCompleteCommand(CommandSender sender, String commandLine) {
+        // IvanCord start - replace
+        return commandDispatcher.completeWithNames( sender, commandLine );
+        /*
         List<String> suggestions = new java.util.ArrayList<>();
 
         if (commandLine.indexOf(' ') == -1) {
@@ -272,9 +369,17 @@ public final class PluginManager
         }
 
         return suggestions;
+         */ // IvanCord end
     }
     // Waterfall end
 
+    // IvanCord start - additional completion stuff
+    public java.util.concurrent.CompletableFuture<Suggestions> getBrigadierCompletions(CommandSender sender, String commandLine)
+    {
+        return commandDispatcher.complete( sender, commandLine );
+    }
+    // IvanCord end
+
     /**
      * Returns the {@link Plugin} objects corresponding to all loaded plugins.
      *
@@ -546,7 +651,8 @@ public final class PluginManager
      */
     public Collection<Map.Entry<String, Command>> getCommands()
     {
-        return Collections.unmodifiableCollection( commandMap.entrySet() );
+        //return Collections.unmodifiableCollection( commandMap.entrySet() ); // IvanCord
+        return commandDispatcher.getCommands(); // IvanCord
     }
 
     boolean isTransitiveDepend(PluginDescription plugin, PluginDescription depend)
@@ -640,4 +746,17 @@ public final class PluginManager
         return plugins.containsKey( plugin.getDescription().getName() );
     }
     // IvanCord end
+
+    // IvanCord start - commands as brigadier commands :)
+
+    /**
+     * Gets all registered commands as brigadier commands.
+     *
+     * @return unmodifiable collection of brigadier commands
+     */
+    public Collection<CommandNode<CommandSender>> getCommandsAsBrigadier()
+    {
+        return commandDispatcher.getBrigadierCommands();
+    }
+    // IvanCord end
 }
diff --git a/chat/src/main/java/net/md_5/bungee/api/ChatColor.java b/chat/src/main/java/net/md_5/bungee/api/ChatColor.java
index d7747deb3352b506ba2998253c7c9a55e045bb9b..ed960716cc21fa20893b7e1800cb0f9f70a0c6dc 100644
--- a/chat/src/main/java/net/md_5/bungee/api/ChatColor.java
+++ b/chat/src/main/java/net/md_5/bungee/api/ChatColor.java
@@ -273,6 +273,19 @@ public final class ChatColor
         throw new IllegalArgumentException( "Could not parse ChatColor " + string );
     }
 
+    // IvanCord start - sorry md_5, but
+    /**
+     * Returns the named colors. A named color is a color which is present in minecraft from before hex colors were
+     * introduced.
+     *
+     * @return named colors. this also includes formatting
+     */
+    public static java.util.Collection<ChatColor> getNamedColors()
+    {
+        return java.util.Collections.unmodifiableCollection( BY_CHAR.values() );
+    }
+    // IvanCord
+
     /**
      * See {@link Enum#valueOf(java.lang.Class, java.lang.String)}.
      *
@@ -296,6 +309,7 @@ public final class ChatColor
      *
      * @return copied array of all colors and formats
      * @deprecated holdover from when this class was an enum
+     * @see #getNamedColors()
      */
     @Deprecated
     public static ChatColor[] values()
diff --git a/chat/src/main/java/net/md_5/bungee/chat/ComponentSerializer.java b/chat/src/main/java/net/md_5/bungee/chat/ComponentSerializer.java
index f1a38151cfb92488aaf54706caec429429e35ae3..22e8637159b8c115cfe1e39d39fc14a80e30dd6d 100644
--- a/chat/src/main/java/net/md_5/bungee/chat/ComponentSerializer.java
+++ b/chat/src/main/java/net/md_5/bungee/chat/ComponentSerializer.java
@@ -43,6 +43,23 @@ public class ComponentSerializer implements JsonDeserializer<BaseComponent>
 
     public static final ThreadLocal<Set<BaseComponent>> serializedComponents = new ThreadLocal<Set<BaseComponent>>();
 
+    // IvanCord start
+    public static BaseComponent[] parse(com.google.gson.stream.JsonReader reader)
+    {
+        JsonElement element = JsonParser.parseReader( reader );
+        if ( element.isJsonArray() )
+        {
+            return gson.fromJson( element, BaseComponent[].class );
+        } else
+        {
+            return new BaseComponent[]
+            {
+                gson.fromJson( element, BaseComponent.class )
+            };
+        }
+    }
+    // IvanCord end
+
     public static BaseComponent[] parse(String json)
     {
         JsonElement jsonElement = JSON_PARSER.parse( json );
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ColorArgument.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ColorArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..65e127f69f69bea4d9606a7daaa7cb57b4c62b4e
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ColorArgument.java
@@ -0,0 +1,79 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import com.mrivanplays.ivancord.api.command.message.BungeeMessage;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Locale;
+import java.util.concurrent.CompletableFuture;
+import net.md_5.bungee.api.ChatColor;
+
+/**
+ * A BungeeCord implementation of the {@code minecraft:color} argument
+ */
+public class ColorArgument implements ArgumentType<ChatColor>
+{
+
+    private static final Collection<String> EXAMPLES = Arrays.asList( "red", "RED", "reset", "green" );
+    public static final DynamicCommandExceptionType ERROR_INVALID_VALUE = new DynamicCommandExceptionType
+        ( ( arg ) -> BungeeMessage.createOfTranslatable( "argument.color.invalid", ChatColor.RED, arg ) );
+
+    private ColorArgument()
+    {
+    }
+
+    public static ColorArgument color()
+    {
+        return new ColorArgument();
+    }
+
+    @Override
+    public ChatColor parse(StringReader reader) throws CommandSyntaxException
+    {
+        String read = reader.readUnquotedString();
+        ChatColor color;
+        try
+        {
+            color = ChatColor.of( read );
+        } catch ( IllegalArgumentException e )
+        {
+            throw ERROR_INVALID_VALUE.create( read );
+        }
+        if ( color.getColor() == null )
+        {
+            throw ERROR_INVALID_VALUE.create( read );
+        }
+        return color;
+    }
+
+    @Override
+    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> context, SuggestionsBuilder builder)
+    {
+        String remainingLowercase = builder.getRemaining().toLowerCase( Locale.ROOT );
+        for ( ChatColor named : ChatColor.getNamedColors() )
+        {
+            if ( named.getColor() == null )
+            {
+                // formatting, no
+                continue;
+            }
+            if ( named.getName().toLowerCase( Locale.ROOT ).startsWith( remainingLowercase ) )
+            {
+                builder.suggest( named.getName() );
+            }
+        }
+        return builder.buildFuture();
+    }
+
+    @Override
+    public Collection<String> getExamples()
+    {
+        return EXAMPLES;
+    }
+}
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ComponentArgument.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ComponentArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2f878a04e4d43dc03fc550f844b6a4a04b099d4
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ComponentArgument.java
@@ -0,0 +1,84 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import com.google.gson.stream.JsonReader;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mrivanplays.ivancord.api.command.message.BungeeMessage;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Collection;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
+/**
+ * A BungeeCord implementation of the minecraft:component argument
+ */
+public class ComponentArgument implements ArgumentType<BaseComponent[]>
+{
+
+    private static final Collection<String> EXAMPLES = Arrays.asList( "\"hello world\"", "\"\"", "\"{\"text\":\"hello world\"}", "[\"\"]" );
+    public static final DynamicCommandExceptionType ERROR_INVALID_JSON = new DynamicCommandExceptionType
+        ( (arg) -> BungeeMessage.createOfTranslatable( "argument.component.invalid", ChatColor.RED, arg ) );
+
+    private ComponentArgument()
+    {
+    }
+
+    public static BaseComponent[] getComponent(CommandContext<?> context, String argName)
+    {
+        return context.getArgument( argName, BaseComponent[].class );
+    }
+
+    public static ComponentArgument component()
+    {
+        return new ComponentArgument();
+    }
+
+    @Override
+    public BaseComponent[] parse(StringReader reader) throws CommandSyntaxException
+    {
+        try
+        {
+            JsonReader jsonReader = new JsonReader( new java.io.StringReader( reader.getRemaining() ) );
+            jsonReader.setLenient( false );
+            BaseComponent[] component = ComponentSerializer.parse( jsonReader );
+            reader.setCursor( reader.getCursor() + getPos( jsonReader ) );
+            if ( component == null )
+            {
+                throw ERROR_INVALID_JSON.createWithContext( reader, "empty" );
+            }
+            return component;
+        } catch ( StackOverflowError e )
+        {
+            String message = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();
+            throw ERROR_INVALID_JSON.createWithContext( reader, message );
+        }
+    }
+
+    private int getPos(JsonReader jsonReader)
+    {
+        try
+        {
+            Field pos = JsonReader.class.getDeclaredField( "pos" );
+            pos.setAccessible( true );
+
+            Field lineStart = JsonReader.class.getDeclaredField( "lineStart" );
+            lineStart.setAccessible( true );
+
+            return pos.getInt( jsonReader ) - lineStart.getInt( jsonReader ) + 1;
+        } catch ( NoSuchFieldException | IllegalAccessException e )
+        {
+            throw new IllegalStateException( "Couldn't read position of JsonReader", e );
+        }
+    }
+
+    @Override
+    public Collection<String> getExamples()
+    {
+        return EXAMPLES;
+    }
+}
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/PlayerArgument.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/PlayerArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..08fb8bf5fad1f25c4d825011109fe111f0d26508
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/PlayerArgument.java
@@ -0,0 +1,200 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import com.mojang.brigadier.LiteralMessage;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import com.mrivanplays.ivancord.api.command.message.BungeeMessage;
+import com.mrivanplays.ivancord.api.util.Either;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.stream.Collectors;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+import net.md_5.bungee.api.ChatColor;
+
+/**
+ * A BungeeCord implementation of the {@code minecraft:game_profile}
+ * argument
+ * <p>
+ * Drawbacks:
+ * <ul>
+ *     <li>Selector {@code @e} returns all players rather than <i>all entities</i></li>
+ *     <li>Selector {@code @s} will return an empty list.</li>
+ *     <li>Selectors doesn't support options</li>
+ * </ul>
+ * <p>
+ * As all drawbacks are about the selector, so that's why we've added an option to disable parsing selectors.
+ */
+public class PlayerArgument implements ArgumentType<PlayerArgument.Result>
+{
+
+    private static final List<String> SELECTOR_VALUES =
+        Arrays.asList( "@p", "@a", "@r", "@s", "@e" );
+
+    private static final Collection<String> EXAMPLES = Arrays.asList( "Player", "0123", "dd12be42-52a9-4a91-a8a1-11c01849e498", "@e" );
+    public static final SimpleCommandExceptionType UNKNOWN_PLAYER =
+        new SimpleCommandExceptionType( BungeeMessage.createOfTranslatable( "argument.player.unknown", ChatColor.RED ) );
+    public static final DynamicCommandExceptionType SELECTOR_UNKNOWN =
+        new DynamicCommandExceptionType( object ->
+            BungeeMessage.createOfTranslatable( "argument.entity.selector.unknown", ChatColor.RED, object ) );
+    public static final SimpleCommandExceptionType SELECTOR_NOT_ENABLED =
+        new SimpleCommandExceptionType( new LiteralMessage( "Sorry, selectors cannot be used here." ) );
+
+    public static PlayerArgument player()
+    {
+        return player( true );
+    }
+
+    public static PlayerArgument disableSelectors()
+    {
+        return player( false );
+    }
+
+    public static PlayerArgument player(boolean allowSelectors)
+    {
+        return new PlayerArgument( allowSelectors );
+    }
+
+    public static Collection<ProtoPlayer> getPlayers(CommandContext<?> context, String name)
+    {
+        return context.getArgument( name, PlayerArgument.Result.class ).getPlayers();
+    }
+
+    private final boolean allowSelectors;
+
+    private PlayerArgument(boolean allowSelectors)
+    {
+        this.allowSelectors = allowSelectors;
+    }
+
+    @Override
+    public PlayerArgument.Result parse(StringReader reader) throws CommandSyntaxException
+    {
+        if ( reader.canRead() && reader.peek() == '@' )
+        {
+            if ( !allowSelectors )
+            {
+                throw SELECTOR_NOT_ENABLED.create();
+            }
+            reader.skip();
+            int cursor = reader.getCursor();
+            char selectorChar = reader.read();
+
+            ProtoPlayerProvider provider = ProtoPlayerProviderI.provide();
+            // todo: perhaps support options?
+            switch ( selectorChar )
+            {
+                case 'p':
+                    List<ProtoPlayer> players = provider.players();
+                    if ( players.isEmpty() )
+                    {
+                        return new PlayerArgument.Result( Collections.emptyList() );
+                    }
+                    List<ProtoPlayer> playerList =
+                        players.stream()
+                            .sorted( (o1, o2) -> Double.compare( 0, provider.distanceToSq( o1, o2 ) ) )
+                            .collect( Collectors.toList() );
+                    return new PlayerArgument.Result( Collections.singletonList( playerList.get( 0 ) ) );
+                case 'a':
+                    return new PlayerArgument.Result( provider.players() );
+                case 'r':
+                    List<ProtoPlayer> ps = provider.players();
+                    int random = ThreadLocalRandom.current().nextInt( 0, ps.size() - 1 );
+                    return new PlayerArgument.Result( Collections.singletonList( ps.get( random ) ) );
+                case 's':
+                    return new PlayerArgument.Result( Collections.emptyList() );
+                default:
+                    if ( selectorChar != 'e' )
+                    {
+                        reader.setCursor( cursor );
+                        throw SELECTOR_UNKNOWN.createWithContext( reader, "@" + selectorChar );
+                    }
+                    return new PlayerArgument.Result( provider.players() );
+            }
+        } else
+        {
+            int cursor = reader.getCursor();
+            while ( reader.canRead() && reader.peek() != ' ' )
+            {
+                reader.skip();
+            }
+
+            ProtoPlayerProvider provider = ProtoPlayerProviderI.provide();
+            String nameOrUuid = reader.getString().substring( cursor, reader.getCursor() );
+            ProtoPlayer player = provider.getProtoPlayer( nameOrUuid );
+            if ( player == null )
+            {
+                throw UNKNOWN_PLAYER.create();
+            } else
+            {
+                return new PlayerArgument.Result( Collections.singletonList( player ) );
+            }
+        }
+    }
+
+    @Override
+    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> context, SuggestionsBuilder builder)
+    {
+        String remaining = builder.getRemaining().toLowerCase( Locale.ROOT );
+        if ( allowSelectors )
+        {
+            if ( remaining.equalsIgnoreCase( "@" ) )
+            {
+                // these are the only reliable selectors, that's why we're going to suggest only these
+                builder.suggest( "@a" );
+                builder.suggest( "@r" );
+            } else
+            {
+                for ( String value : SELECTOR_VALUES )
+                {
+                    if ( remaining.equalsIgnoreCase( value ) )
+                    {
+                        builder.suggest( value );
+                    }
+                }
+            }
+        }
+        for ( String name : ProtoPlayerProviderI.provide().getPlayersByName() )
+        {
+            if ( name.toLowerCase( Locale.ROOT ).startsWith( remaining ) )
+            {
+                builder.suggest( name );
+            }
+        }
+        return builder.buildFuture();
+    }
+
+    @Override
+    public Collection<String> getExamples()
+    {
+        return EXAMPLES;
+    }
+
+    @Getter
+    @RequiredArgsConstructor
+    public static final class Result
+    {
+
+        private final Collection<ProtoPlayer> players;
+    }
+
+    @Getter
+    @RequiredArgsConstructor
+    public static final class ProtoPlayer
+    {
+
+        private final Either<String, UUID> nameOrUUID;
+    }
+}
\ No newline at end of file
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProvider.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb6257c6829f1a94b45d7cb701e55f4c90edfe79
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProvider.java
@@ -0,0 +1,15 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import java.util.List;
+
+interface ProtoPlayerProvider
+{
+
+    PlayerArgument.ProtoPlayer getProtoPlayer(String nameOrUUID);
+
+    double distanceToSq(PlayerArgument.ProtoPlayer player1, PlayerArgument.ProtoPlayer player2);
+
+    List<PlayerArgument.ProtoPlayer> players();
+
+    List<String> getPlayersByName();
+}
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProviderI.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProviderI.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d822c3a1afd4cb7e83e9bfe2c35d81081292be2
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/arguments/ProtoPlayerProviderI.java
@@ -0,0 +1,21 @@
+package com.mrivanplays.ivancord.api.command.arguments;
+
+import com.google.common.base.Preconditions;
+
+class ProtoPlayerProviderI
+{
+
+    private static ProtoPlayerProvider instance;
+
+    static ProtoPlayerProvider provide()
+    {
+        return instance;
+    }
+
+    static void set(ProtoPlayerProvider val)
+    {
+        Preconditions.checkNotNull( val, "val" );
+        Preconditions.checkState( instance == null, "Instance already set" );
+        instance = val;
+    }
+}
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java
new file mode 100644
index 0000000000000000000000000000000000000000..024c64dac1efa0d9b42efecfc9923a23fa5b4604
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java
@@ -0,0 +1,149 @@
+package com.mrivanplays.ivancord.api.command.message;
+
+import com.google.gson.JsonSyntaxException;
+import com.mojang.brigadier.Message;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.chat.TranslatableComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
+/**
+ * Represents a BungeeCord implementation of the Brigadier's {@link Message} interface.
+ * With it, you are able to send custom messages to the command senders, using
+ * {@link com.mojang.brigadier.suggestion.SuggestionsBuilder#suggest(String, Message)}
+ */
+public final class BungeeMessage implements Message
+{
+
+    /**
+     * A utility method to create a {@link BungeeMessage} with a message of {@link TranslatableComponent}
+     * with the appropriate translation {@code id}
+     *
+     * @param id the translation id
+     * @param with the {@link String}s and {@link BaseComponent}s to use in the translation
+     * @return new bungee message instance
+     */
+    public static BungeeMessage createOfTranslatable(String id, ChatColor color, Object... with)
+    {
+        TranslatableComponent component = new TranslatableComponent( id, with );
+        component.setColor( color );
+        return new BungeeMessage( component );
+    }
+
+    /**
+     * Converts the provided {@link CommandSyntaxException} into a BungeeCord style message.
+     *
+     * @param exception the exception provided
+     * @return a message that could be directly sent to a CommandExecutor
+     */
+    public static BaseComponent convertSyntaxException(CommandSyntaxException exception)
+    {
+        Message rawMessage = exception.getRawMessage();
+        TextComponent text;
+        if ( rawMessage instanceof BungeeMessage )
+        {
+            BungeeMessage bungeeMessage = (BungeeMessage) rawMessage;
+            text = new TextComponent( bungeeMessage.getMessage() );
+        } else
+        {
+            try
+            {
+                BaseComponent[] parsedJson = ComponentSerializer.parse( rawMessage.getString() );
+                text = new TextComponent( parsedJson );
+            } catch ( JsonSyntaxException e )
+            {
+                text = new TextComponent( rawMessage.getString() );
+                text.setColor( ChatColor.RED );
+            }
+        }
+
+        TextComponent context = convertContextOf( exception );
+
+        if ( context != null )
+        {
+            TranslatableComponent ret =
+                new TranslatableComponent( "command.context.parse_error", text, exception.getCursor(), context );
+            ret.setColor( ChatColor.RED );
+            return ret;
+        }
+
+        return text;
+    }
+
+    /**
+     * Converts {@link CommandSyntaxException#getContext()} to a component.
+     *
+     * @param exception the exception provided
+     * @return converted context, or null
+     */
+    public static TextComponent convertContextOf(CommandSyntaxException exception)
+    {
+        String input = exception.getInput();
+        int startingCursor = exception.getCursor();
+        if ( input == null || startingCursor < 0 )
+        {
+            return null;
+        }
+
+        TextComponent component = new TextComponent();
+        int cursor = Math.min( input.length(), startingCursor );
+        if ( cursor > CommandSyntaxException.CONTEXT_AMOUNT )
+        {
+            component.addExtra( "..." );
+        }
+        component.addExtra( input.substring( Math.max( 0, cursor - CommandSyntaxException.CONTEXT_AMOUNT ), cursor ) );
+        component.setColor( ChatColor.GRAY );
+
+        TranslatableComponent hereParam = new TranslatableComponent( "command.context.here" );
+        hereParam.setColor( ChatColor.RED );
+        component.addExtra( hereParam );
+
+        return component;
+    }
+
+    private final String legacyText;
+    private final BaseComponent[] message;
+
+    /**
+     * Creates a new {@link BungeeMessage}
+     *
+     * @param text components
+     */
+    public BungeeMessage(BaseComponent... text)
+    {
+        this.message = text;
+        if ( this.message != null )
+        {
+            this.legacyText = BaseComponent.toLegacyText( text );
+        } else
+        {
+            this.legacyText = null;
+        }
+    }
+
+    /**
+     * Returns the message provided.
+     *
+     * @return message
+     */
+    public BaseComponent[] getMessage()
+    {
+        return message;
+    }
+
+    @Override
+    public String getString()
+    {
+        return this.legacyText;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "BungeeMessage{" +
+            "message=" + this.legacyText +
+            '}';
+    }
+}
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/util/Either.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/util/Either.java
new file mode 100644
index 0000000000000000000000000000000000000000..2305506d309c9c671eb0492a61c00cc6f6ed86fc
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/util/Either.java
@@ -0,0 +1,64 @@
+package com.mrivanplays.ivancord.api.util;
+
+import java.util.Optional;
+
+/**
+ * A utility class, containing either 1 of the 2 types of data
+ *
+ * @param <T1> type 1
+ * @param <T2> type 2
+ */
+public final class Either<T1, T2>
+{
+
+    private final Optional<T1> value1;
+    private final Optional<T2> value2;
+    private final PresentDirection presentDirection;
+    private final boolean bothPresent;
+
+    public Either(T1 t1, T2 t2)
+    {
+        value1 = Optional.ofNullable( t1 );
+        value2 = Optional.ofNullable( t2 );
+
+        if ( value1.isPresent() )
+        {
+            presentDirection = PresentDirection.LEFT;
+        } else if ( value2.isPresent() )
+        {
+            presentDirection = PresentDirection.RIGHT;
+        } else
+        {
+            presentDirection = PresentDirection.NONE;
+        }
+
+        bothPresent = value1.isPresent() && value2.isPresent();
+    }
+
+    public PresentDirection getPresentDirection()
+    {
+        return presentDirection;
+    }
+
+    public boolean areBothPresent()
+    {
+        return bothPresent;
+    }
+
+    public Optional<T1> getLeft()
+    {
+        return value1;
+    }
+
+    public Optional<T2> getRight()
+    {
+        return value2;
+    }
+
+    public enum PresentDirection
+    {
+        LEFT,
+        RIGHT,
+        NONE
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
index 0eb3661bb5723560f73340b0d33e19b42b1c0bf0..e8f39807dbb14a1b1ea31d1592d8d4309804f382 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
@@ -4,6 +4,7 @@ import com.google.common.base.Preconditions;
 import com.mojang.brigadier.Command;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.BoolArgumentType; // IvanCord
 import com.mojang.brigadier.arguments.DoubleArgumentType;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
@@ -21,6 +22,11 @@ import com.mojang.brigadier.tree.ArgumentCommandNode;
 import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.LiteralCommandNode;
 import com.mojang.brigadier.tree.RootCommandNode;
+// IvanCord start
+import com.mrivanplays.ivancord.api.command.arguments.ColorArgument;
+import com.mrivanplays.ivancord.api.command.arguments.ComponentArgument;
+import com.mrivanplays.ivancord.api.command.arguments.PlayerArgument;
+// IvanCord end
 import io.netty.buffer.ByteBuf;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
@@ -325,19 +331,34 @@ public class Commands extends DefinedPacket
             {
             }
         };
-        private static final ArgumentSerializer<Boolean> BOOLEAN = new ArgumentSerializer<Boolean>()
+        private static final ProperArgumentSerializer<BoolArgumentType> BOOLEAN = new ProperArgumentSerializer<BoolArgumentType>() // IvanCord
         {
             @Override
-            protected Boolean read(ByteBuf buf)
+            protected BoolArgumentType read(ByteBuf buf) // IvanCord
             {
-                return buf.readBoolean();
+                return BoolArgumentType.bool(); // IvanCord
             }
 
             @Override
-            protected void write(ByteBuf buf, Boolean t)
+            protected void write(ByteBuf buf, BoolArgumentType t) // IvanCord
             {
-                buf.writeBoolean( t );
+                // IvanCord - NOOP
+                //buf.writeBoolean( t );
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:bool";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 0;
+            }
+            // IvanCord end
         };
         private static final ArgumentSerializer<Byte> BYTE = new ArgumentSerializer<Byte>()
         {
@@ -353,7 +374,7 @@ public class Commands extends DefinedPacket
                 buf.writeByte( t );
             }
         };
-        private static final ArgumentSerializer<FloatArgumentType> FLOAT = new ArgumentSerializer<FloatArgumentType>()
+        private static final ProperArgumentSerializer<FloatArgumentType> FLOAT = new ProperArgumentSerializer<FloatArgumentType>() // IvanCord
         {
             @Override
             protected FloatArgumentType read(ByteBuf buf)
@@ -381,8 +402,22 @@ public class Commands extends DefinedPacket
                     buf.writeFloat( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:float";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 1;
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<DoubleArgumentType> DOUBLE = new ArgumentSerializer<DoubleArgumentType>()
+        private static final ProperArgumentSerializer<DoubleArgumentType> DOUBLE = new ProperArgumentSerializer<DoubleArgumentType>() // IvanCord
         {
             @Override
             protected DoubleArgumentType read(ByteBuf buf)
@@ -410,8 +445,22 @@ public class Commands extends DefinedPacket
                     buf.writeDouble( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:double";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 2;
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<IntegerArgumentType> INTEGER = new ArgumentSerializer<IntegerArgumentType>()
+        private static final ProperArgumentSerializer<IntegerArgumentType> INTEGER = new ProperArgumentSerializer<IntegerArgumentType>() // IvanCord
         {
             @Override
             protected IntegerArgumentType read(ByteBuf buf)
@@ -439,8 +488,22 @@ public class Commands extends DefinedPacket
                     buf.writeInt( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:integer";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 3;
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<LongArgumentType> LONG = new ArgumentSerializer<LongArgumentType>()
+        private static final ProperArgumentSerializer<LongArgumentType> LONG = new ProperArgumentSerializer<LongArgumentType>() // IvanCord
         {
             @Override
             protected LongArgumentType read(ByteBuf buf)
@@ -468,6 +531,20 @@ public class Commands extends DefinedPacket
                     buf.writeLong( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:long";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 4;
+            }
+            // IvanCord end
         };
         private static final ProperArgumentSerializer<StringArgumentType> STRING = new ProperArgumentSerializer<StringArgumentType>()
         {
@@ -521,19 +598,112 @@ public class Commands extends DefinedPacket
             }
         };
 
+        // IvanCord start - minecraft:game_profile serializer
+        private static final ProperArgumentSerializer<PlayerArgument> GAME_PROFILE = new ProperArgumentSerializer<PlayerArgument>()
+        {
+
+            @Override
+            protected String getKey()
+            {
+                return "minecraft:game_profile";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 7;
+            }
+
+            @Override
+            protected PlayerArgument read(ByteBuf buf)
+            {
+                return PlayerArgument.player();
+            }
+
+            @Override
+            protected void write(ByteBuf buf, PlayerArgument playerArgument)
+            {
+                // noop
+            }
+        };
+        // minecraft:color serializer
+        private static final ProperArgumentSerializer<ColorArgument> COLOR = new ProperArgumentSerializer<ColorArgument>()
+        {
+
+            @Override
+            protected String getKey()
+            {
+                return "minecraft:color";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 16;
+            }
+
+            @Override
+            protected ColorArgument read(ByteBuf buf)
+            {
+                return ColorArgument.color();
+            }
+
+            @Override
+            protected void write(ByteBuf buf, ColorArgument colorArgument)
+            {
+                // noop
+            }
+        };
+        // minecraft:component serializer
+        private static final ProperArgumentSerializer<ComponentArgument> COMPONENT = new ProperArgumentSerializer<ComponentArgument>()
+        {
+
+            @Override
+            protected String getKey()
+            {
+                return "minecraft:component";
+            }
+
+            @Override
+            protected int getIntKey()
+            {
+                return 17;
+            }
+
+            @Override
+            protected ComponentArgument read(ByteBuf buf)
+            {
+                return ComponentArgument.component();
+            }
+
+            @Override
+            protected void write(ByteBuf buf, ComponentArgument componentArgument)
+            {
+                // noop
+            }
+        };
+        // IvanCord end
+
         static
         {
             register( "brigadier:bool", VOID );
+            PROPER_PROVIDERS.put( BoolArgumentType.class, BOOLEAN ); // IvanCord
             register( "brigadier:float", FLOAT );
+            PROPER_PROVIDERS.put( FloatArgumentType.class, FLOAT ); // IvanCord
             register( "brigadier:double", DOUBLE );
+            PROPER_PROVIDERS.put( DoubleArgumentType.class, DOUBLE ); // IvanCord
             register( "brigadier:integer", INTEGER );
+            PROPER_PROVIDERS.put( IntegerArgumentType.class, INTEGER ); // IvanCord
             register( "brigadier:long", LONG );
+            PROPER_PROVIDERS.put( LongArgumentType.class, LONG ); // IvanCord
 
             register( "brigadier:string", STRING );
             PROPER_PROVIDERS.put( StringArgumentType.class, STRING );
 
+            // IvanCord TODO: Create serializers for the useful arguments down there
             register( "minecraft:entity", BYTE );
             register( "minecraft:game_profile", VOID );
+            PROPER_PROVIDERS.put( PlayerArgument.class, GAME_PROFILE ); // IvanCord
             register( "minecraft:block_pos", VOID );
             register( "minecraft:column_pos", VOID );
             register( "minecraft:vec3", VOID );
@@ -543,7 +713,9 @@ public class Commands extends DefinedPacket
             register( "minecraft:item_stack", VOID );
             register( "minecraft:item_predicate", VOID );
             register( "minecraft:color", VOID );
+            PROPER_PROVIDERS.put( ColorArgument.class, COLOR ); // IvanCord
             register( "minecraft:component", VOID );
+            PROPER_PROVIDERS.put( ComponentArgument.class, COMPONENT ); // IvanCord
             register( "minecraft:message", VOID );
             register( "minecraft:nbt_compound_tag", VOID ); // 1.14
             register( "minecraft:nbt_tag", VOID ); // 1.14
@@ -671,15 +843,28 @@ public class Commands extends DefinedPacket
     {
 
         public static final SuggestionProvider ASK_SERVER = new DummyProvider( "minecraft:ask_server" );
+        // IvanCord start
+        public static final SuggestionProvider ALL_RECIPES = new DummyProvider( "minecraft:all_recipes" );
+        public static final SuggestionProvider AVAILABLE_SOUNDS = new DummyProvider( "minecraft:available_sounds" );
+        public static final SuggestionProvider AVAILABLE_BIOMES = new DummyProvider( "minecraft:available_biomes" );
+        public static final SuggestionProvider SUMMONABLE_ENTITIES = new DummyProvider( "minecraft:summonable_entities" );
+        // IvanCord end
         private static final Map<String, SuggestionProvider<DummyProvider>> PROVIDERS = new HashMap<>();
 
         static
         {
             PROVIDERS.put( "minecraft:ask_server", ASK_SERVER );
+            // IvanCord start - no dummies - expose SuggestionRegistry
+            PROVIDERS.put( "minecraft:all_recipes", ALL_RECIPES );
+            PROVIDERS.put( "minecraft:available_sounds", AVAILABLE_SOUNDS );
+            PROVIDERS.put( "minecraft:available_biomes", AVAILABLE_BIOMES );
+            PROVIDERS.put( "minecraft:summonable_entities", SUMMONABLE_ENTITIES );
+            /*
             registerDummy( "minecraft:all_recipes" );
             registerDummy( "minecraft:available_sounds" );
             registerDummy( "minecraft:available_biomes" );
             registerDummy( "minecraft:summonable_entities" );
+             */ // IvanCord end
         }
 
         private static void registerDummy(String name)
@@ -697,9 +882,20 @@ public class Commands extends DefinedPacket
 
         private static String getKey(SuggestionProvider<DummyProvider> provider)
         {
+            // IvanCord start - change
+            if ( provider instanceof DummyProvider )
+            {
+                return ( (DummyProvider) provider ).key;
+            } else
+            {
+                // in case mojang changes it
+                return ( (DummyProvider) ASK_SERVER ).key;
+            }
+            /*
             Preconditions.checkArgument( provider instanceof DummyProvider, "Non dummy provider " + provider );
 
             return ( (DummyProvider) provider ).key;
+             */ // IvanCord end
         }
 
         @Data
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
index 21aa9675081adf6213c37aba51a33b4fae39a859..31408d5506dfef5a0b6f22444746e94638272abc 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
@@ -53,7 +53,39 @@ public class TabCompleteResponse extends DefinedPacket
                 String match = readString( buf );
                 String tooltip = buf.readBoolean() ? readString( buf ) : null;
 
+                // IvanCord start - replace
+                /*
                 matches.add( new Suggestion( range, match, new LiteralMessage( tooltip ) ) );
+                 */
+                if ( tooltip != null )
+                {
+                    try
+                    {
+                        net.md_5.bungee.api.chat.BaseComponent[] message =
+                            net.md_5.bungee.chat.ComponentSerializer.parse( tooltip );
+                        matches.add(
+                            new Suggestion(
+                                range, match,
+                                new com.mrivanplays.ivancord.api.command.message.BungeeMessage( message )
+                            )
+                        );
+                    } catch ( com.google.gson.JsonSyntaxException e )
+                    {
+                        // convert to json
+                        matches.add(
+                            new Suggestion(
+                                range, match,
+                                new com.mrivanplays.ivancord.api.command.message.BungeeMessage(
+                                    net.md_5.bungee.api.chat.TextComponent.fromLegacyText( tooltip )
+                                )
+                            )
+                        );
+                    }
+                } else
+                {
+                    matches.add( new Suggestion( range, match ) );
+                }
+                // IvanCord end
             }
 
             suggestions = new Suggestions( range, matches );
@@ -76,11 +108,53 @@ public class TabCompleteResponse extends DefinedPacket
             for ( Suggestion suggestion : suggestions.getList() )
             {
                 writeString( suggestion.getText(), buf );
+                // IvanCord start - rewrite this
+                /*
                 buf.writeBoolean( suggestion.getTooltip() != null && suggestion.getTooltip().getString() != null );
                 if ( suggestion.getTooltip() != null && suggestion.getTooltip().getString() != null )
                 {
                     writeString( suggestion.getTooltip().getString(), buf );
                 }
+                 */
+                if ( suggestion.getTooltip() != null )
+                {
+                    com.mojang.brigadier.Message tooltip = suggestion.getTooltip();
+                    if ( tooltip instanceof com.mrivanplays.ivancord.api.command.message.BungeeMessage )
+                    {
+                        com.mrivanplays.ivancord.api.command.message.BungeeMessage
+                            bungee = (com.mrivanplays.ivancord.api.command.message.BungeeMessage) tooltip;
+                        buf.writeBoolean( bungee.getMessage() != null );
+                        if ( bungee.getMessage() != null )
+                        {
+                            writeString( net.md_5.bungee.chat.ComponentSerializer.toString( bungee.getMessage() ), buf );
+                        }
+                    } else
+                    {
+                        buf.writeBoolean( tooltip.getString() != null );
+                        if ( tooltip.getString() != null )
+                        {
+                            // make sure this is json - otherwise we'll have some trouble
+                            try
+                            {
+                                net.md_5.bungee.chat.ComponentSerializer.parse( tooltip.getString() );
+                                writeString( tooltip.getString(), buf );
+                            } catch ( com.google.gson.JsonSyntaxException e )
+                            {
+                                // not json, have to use text components
+                                writeString(
+                                    net.md_5.bungee.chat.ComponentSerializer.toString(
+                                        new net.md_5.bungee.api.chat.TextComponent( tooltip.getString() )
+                                    ),
+                                    buf
+                                );
+                            }
+                        }
+                    }
+                } else
+                {
+                    buf.writeBoolean( false );
+                }
+                // IvanCord end
             }
         } else
         {
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index a8a2499555b007b6ee6a4534d5727a4bd56d51da..e114f39d1e4bc25616fb5abb5d168641bf056fba 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -915,5 +915,22 @@ public class BungeeCord extends ProxyServer
     {
         return playerdata.getOfflinePlayers();
     }
+
+    @Override
+    public ProxiedPlayer getPlayerFromProto(com.mrivanplays.ivancord.api.command.arguments.PlayerArgument.ProtoPlayer protoPlayer)
+    {
+        com.mrivanplays.ivancord.api.util.Either<String, UUID> either = protoPlayer.getNameOrUUID();
+        switch ( either.getPresentDirection() )
+        {
+            case NONE:
+                return null;
+            case LEFT:
+                return getPlayer( either.getLeft().get() );
+            case RIGHT:
+                return getPlayer( either.getRight().get() );
+            default:
+                throw new RuntimeException( "Invalid Either#PresentDirection: " + either.getPresentDirection() );
+        }
+    }
     // IvanCord end
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
index 26e9506530bcea8e52b94028291f06968d545f1f..326f28e6188dab60b0c9cdf91cc14b4a0869513e 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
@@ -6,12 +6,15 @@ import com.google.common.collect.Lists;
 import com.google.common.io.ByteArrayDataOutput;
 import com.google.common.io.ByteStreams;
 import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.ArgumentBuilder; // IvanCord
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
 import com.mojang.brigadier.context.StringRange;
 import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
 import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.RootCommandNode; // IvanCord
+import io.github.waterfallmc.waterfall.event.ProxyDefineCommandsEvent; // Waterfall
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.Unpooled;
@@ -28,6 +31,7 @@ import net.md_5.bungee.ServerConnection;
 import net.md_5.bungee.ServerConnection.KeepAliveData;
 import net.md_5.bungee.UserConnection;
 import net.md_5.bungee.Util;
+import net.md_5.bungee.api.CommandSender; // IvanCord
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.chat.ComponentBuilder; // IvanCord
 import net.md_5.bungee.api.chat.BaseComponent;
@@ -660,6 +664,65 @@ public class DownstreamBridge extends PacketHandler
     @Override
     public void handle(TabCompleteResponse tabCompleteResponse) throws Exception
     {
+        // IvanCord start - ditch whole impl
+        // rewrite
+        List<String> commands = tabCompleteResponse.getCommands();
+        if ( commands != null )
+        {
+            // legacy
+            TabCompleteResponseEvent tabCompleteEvent = new TabCompleteResponseEvent( server, con, new ArrayList<>( commands ) );
+            if ( !bungee.getPluginManager().callEvent( tabCompleteEvent ).isCancelled() && !commands.equals( tabCompleteEvent.getSuggestions() ) )
+            {
+                tabCompleteResponse.setCommands( tabCompleteEvent.getSuggestions() );
+                con.unsafe().sendPacket( tabCompleteResponse );
+            }
+        } else
+        {
+            // brigadier
+            Suggestions initial = tabCompleteResponse.getSuggestions();
+            com.mrivanplays.ivancord.api.event.BrigadierSuggestionsResponseEvent brigadierEvent =
+                new com.mrivanplays.ivancord.api.event.BrigadierSuggestionsResponseEvent( server, con, initial );
+            if ( !bungee.getPluginManager().callEvent( brigadierEvent ).isCancelled() )
+            {
+                Suggestions fromEvent = brigadierEvent.getSuggestions();
+
+                // call bungee's event so we don't make them plugins bork and devlopers crying
+                commands = new ArrayList<>();
+                for ( Suggestion suggestion : fromEvent.getList() )
+                {
+                    commands.add( suggestion.getText() );
+                }
+                TabCompleteResponseEvent tabCompleteEvent = new TabCompleteResponseEvent( server, con, commands );
+                if ( !bungee.getPluginManager().callEvent( tabCompleteEvent ).isCancelled() )
+                {
+                    List<String> updated = tabCompleteEvent.getSuggestions();
+                    if ( commands.equals( updated ) )
+                    {
+                        // in case the first event changed sth
+                        tabCompleteResponse.setSuggestions( fromEvent );
+                        con.unsafe().sendPacket( tabCompleteResponse );
+                        throw CancelSendSignal.INSTANCE;
+                    }
+
+                    List<Suggestion> suggestions = new ArrayList<>();
+                    for ( Suggestion suggestion : fromEvent.getList() )
+                    {
+                        String value = suggestion.getText();
+                        for ( String update : updated )
+                        {
+                            if ( update.toLowerCase().equalsIgnoreCase( value.toLowerCase() ) )
+                            {
+                                suggestions.add( suggestion );
+                            }
+                        }
+                    }
+
+                    tabCompleteResponse.setSuggestions( new Suggestions( fromEvent.getRange(), suggestions ) );
+                    con.unsafe().sendPacket( tabCompleteResponse );
+                }
+            }
+        }
+        /*
         List<String> commands = tabCompleteResponse.getCommands();
         if ( commands == null )
         {
@@ -700,6 +763,7 @@ public class DownstreamBridge extends PacketHandler
 
             con.unsafe().sendPacket( tabCompleteResponse );
         }
+         */ // IvanCord end
 
         throw CancelSendSignal.INSTANCE;
     }
@@ -762,6 +826,8 @@ public class DownstreamBridge extends PacketHandler
     {
         boolean modified = false;
 
+        // IvanCord start - replace impl completely
+        /*
         // Waterfall start
         Map<String, Command> commandMap = new HashMap<>();
         for ( Map.Entry<String, Command> commandEntry : bungee.getPluginManager().getCommands() ) {
@@ -791,6 +857,43 @@ public class DownstreamBridge extends PacketHandler
                 modified = true;
             }
         }
+         */
+        // since we don't want to expose the CommandDispatcherProxy in PluginManager thats how we should construct
+        // the root node.
+        RootCommandNode<CommandSender> rootCopy = new RootCommandNode<>();
+        for ( CommandNode<CommandSender> node : bungee.getPluginManager().getCommandsAsBrigadier() )
+        {
+            rootCopy.addChild( node );
+        }
+        RootCommandNode<CommandSender> filtered =
+            (RootCommandNode<CommandSender>) filterCommandNode( rootCopy, new java.util.IdentityHashMap<>() );
+        java.util.Collection<CommandNode<CommandSender>> nodes = filtered.getChildren();
+        if ( nodes.isEmpty() )
+        {
+            return;
+        }
+        Map<String, Command> commandMap = new HashMap<>();
+        for ( CommandNode<CommandSender> node : nodes )
+        {
+            Command legacy = bungee.getPluginManager().getCommand( node.getName() );
+            if ( legacy != null )
+            {
+                commandMap.put( node.getName(), legacy );
+            }
+        }
+        ProxyDefineCommandsEvent defineCommandsEvent = new ProxyDefineCommandsEvent( server, con, commandMap );
+        bungee.getPluginManager().callEvent( defineCommandsEvent );
+        Map<String, Command> updatedMap = defineCommandsEvent.getCommands();
+        for ( String name : updatedMap.keySet() )
+        {
+            CommandNode<CommandSender> node = filtered.getChild( name );
+            if ( node != null )
+            {
+                commands.getRoot().addChild( node );
+                modified = true;
+            }
+        }
+        // IvanCord end
 
         if ( modified )
         {
@@ -799,6 +902,68 @@ public class DownstreamBridge extends PacketHandler
         }
     }
 
+    // IvanCord start
+    private CommandNode<CommandSender> filterCommandNode(
+        CommandNode<CommandSender> source,
+        Map<CommandNode<CommandSender>, CommandNode<CommandSender>> commandNodeMapping
+    )
+    {
+        CommandNode<CommandSender> dest;
+        if ( source instanceof RootCommandNode )
+        {
+            dest = new RootCommandNode<>();
+        } else
+        {
+            if ( bungee.getDisabledCommands().contains( source.getName() ) )
+            {
+                commandNodeMapping.put( source, null );
+                return null;
+            }
+            if ( source.getRequirement() != null )
+            {
+                try
+                {
+                    if ( !source.getRequirement().test( con ) )
+                    {
+                        commandNodeMapping.put( source, null );
+                        return null;
+                    }
+                } catch ( Throwable t )
+                {
+                    bungee.getLogger().log( java.util.logging.Level.SEVERE, "Requirement test for command node " + source + " encountered an exception", t );
+                }
+            }
+
+            ArgumentBuilder<CommandSender, ?> destChildBuilder = source.createBuilder();
+            destChildBuilder.requires( sender -> true );
+            if ( destChildBuilder.getRedirect() != null )
+            {
+                if ( commandNodeMapping.containsKey( destChildBuilder.getRedirect() ) )
+                {
+                    destChildBuilder.redirect( commandNodeMapping.get( destChildBuilder.getRedirect() ) );
+                } else
+                {
+                    destChildBuilder.redirect( filterCommandNode( destChildBuilder.getRedirect(), commandNodeMapping ) );
+                }
+            }
+            dest = destChildBuilder.build();
+        }
+
+        for ( CommandNode<CommandSender> sourceChild : source.getChildren() )
+        {
+            CommandNode<CommandSender> destChild = filterCommandNode( sourceChild, commandNodeMapping );
+            if ( destChild == null )
+            {
+                continue;
+            }
+            dest.addChild( destChild );
+        }
+        commandNodeMapping.put( source, dest );
+
+        return dest;
+    }
+    // IvanCord end
+
     // IvanCord start
     @Override
     public void handle(PlayerPosition pac)
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 28165d97190823b29a7ed91b393b1e71bfef406e..5b804c3247edcfa186e270499061730d1797c155 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -231,6 +231,95 @@ public class UpstreamBridge extends PacketHandler
         }
 
         // Waterfall end - tab limiter
+        // IvanCord start - ditch whole impl
+        // reimplement this entirely
+        boolean isRegisteredCommand = false;
+        if ( con.getPendingConnection().getVersion() < ProtocolConstants.MINECRAFT_1_13 )
+        {
+            List<String> suggestions = new ArrayList<>();
+            if ( tabComplete.getCursor().startsWith( "/" ) )
+            {
+                isRegisteredCommand = bungee.getPluginManager().dispatchCommand( con, tabComplete.getCursor().substring( 1 ), suggestions );
+            }
+
+            TabCompleteEvent event = bungee.getPluginManager().callEvent( new TabCompleteEvent( con, con.getServer(), tabComplete.getCursor(), suggestions ) );
+            if ( event.isCancelled() )
+            {
+                throw CancelSendSignal.INSTANCE;
+            }
+
+            List<String> results = event.getSuggestions();
+            if ( !results.isEmpty() )
+            {
+                con.unsafe().sendPacket( new TabCompleteResponse( results ) );
+                throw CancelSendSignal.INSTANCE;
+            }
+        } else
+        {
+            // alright, my turn
+            Suggestions fromDispatcher = Suggestions.empty().join();
+            if ( tabComplete.getCursor().startsWith( "/" ) )
+            {
+                fromDispatcher = bungee.getPluginManager().getBrigadierCompletions( con, tabComplete.getCursor().substring( 1 ) ).join();
+            }
+            isRegisteredCommand = !fromDispatcher.isEmpty();
+            int start = tabComplete.getCursor().lastIndexOf( ' ' ) + 1;
+            int end = tabComplete.getCursor().length();
+            StringRange range = StringRange.between( start, end );
+            Suggestions suggestions = new Suggestions( range, fromDispatcher.getList() );
+
+            com.mrivanplays.ivancord.api.event.BrigadierSuggestionsEvent brigadierEvent =
+                bungee.getPluginManager().callEvent( new com.mrivanplays.ivancord.api.event.BrigadierSuggestionsEvent( con, con.getServer(), tabComplete.getCursor(), suggestions ) );
+            if ( brigadierEvent.isCancelled() )
+            {
+                throw CancelSendSignal.INSTANCE;
+            }
+            Suggestions suggestionsResult = brigadierEvent.getSuggestions();
+            if ( !suggestionsResult.isEmpty() )
+            {
+                // call bungee's event so we don't make them plugins bork and devlopers crying
+                List<String> suggestionsList = new ArrayList<>();
+                for ( Suggestion suggestion : suggestionsResult.getList() )
+                {
+                    suggestionsList.add( suggestion.getText() );
+                }
+                TabCompleteEvent bungeeEvent =
+                    bungee.getPluginManager().callEvent( new TabCompleteEvent( con, con.getServer(), tabComplete.getCursor(), suggestionsList ) );
+                if ( bungeeEvent.isCancelled() )
+                {
+                    throw CancelSendSignal.INSTANCE;
+                }
+
+                List<String> results = bungeeEvent.getSuggestions();
+                if ( !results.isEmpty() )
+                {
+                    List<Suggestion> suggestionList = new ArrayList<>();
+                    for ( Suggestion suggestion : suggestionsResult.getList() )
+                    {
+                        String suggestionText = suggestion.getText();
+                        for ( String result : results )
+                        {
+                            if ( suggestionText.equalsIgnoreCase( result.toLowerCase() ) )
+                            {
+                                suggestionList.add( suggestion );
+                            }
+                        }
+                    }
+                    if ( !suggestionList.isEmpty() )
+                    {
+                        con.unsafe().sendPacket( new TabCompleteResponse( tabComplete.getTransactionId(), new Suggestions( range, suggestionList ) ) );
+                        throw CancelSendSignal.INSTANCE;
+                    }
+                }
+            }
+        }
+
+        // Don't forward tab completions if the command is a registered bungee command
+        if ( isRegisteredCommand )
+        {
+            throw CancelSendSignal.INSTANCE;
+        }
+        /*
         List<String> suggestions = new ArrayList<>();
         boolean isRegisteredCommand = false;
 
@@ -277,6 +366,7 @@ public class UpstreamBridge extends PacketHandler
         {
             throw CancelSendSignal.INSTANCE;
         }
+         */ // IvanCord end
     }
 
     @Override
diff --git a/proxy/src/main/resources/messages.properties b/proxy/src/main/resources/messages.properties
index 8559d1b65d3f387eaee2876fe3632b32246d52de..fb720f9e62d86195faf105ca19af40d198f21648 100644
--- a/proxy/src/main/resources/messages.properties
+++ b/proxy/src/main/resources/messages.properties
@@ -43,3 +43,5 @@ illegal_chat_characters=\u00a7cIllegal characters in chat ({0})
 kick_message=\u00a7cYou have been kicked off the proxy.
 kick_to_lobby=You were kicked from server {0} with reason {1} . The fallback sent you to {2}
 command_plugins_message=Plugins ({0}): {1}
+internal_error_executing=\u00a7cAn internal error occurred whilst executing this command, please check the console log for details.
+internal_error_completing=\u00a7cAn internal error occurred whilst tab completing this command, please check the console log for details.
