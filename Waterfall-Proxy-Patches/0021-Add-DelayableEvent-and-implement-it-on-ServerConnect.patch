From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <pekov.ivan@abv.bg>
Date: Mon, 8 Jul 2019 16:54:00 +0300
Subject: [PATCH] Add DelayableEvent and implement it on ServerConnectEvent


diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/event/DelayableEvent.java b/api/src/main/java/com/mrivanplays/ivancord/api/event/DelayableEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..43747a43f2e6d49d0bebce85ebb52a668530aa96
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/event/DelayableEvent.java
@@ -0,0 +1,87 @@
+package com.mrivanplays.ivancord.api.event;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import com.google.common.base.Preconditions;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import lombok.EqualsAndHashCode;
+import lombok.ToString;
+import net.md_5.bungee.api.Callback;
+import net.md_5.bungee.api.plugin.Event;
+
+/**
+ * Represents a event that allows listeners
+ * to perform certain actions asynchronously
+ * after the specified event was called
+ */
+@ToString(callSuper = true)
+@EqualsAndHashCode(callSuper = true)
+public abstract class DelayableEvent<T> extends Event
+{
+
+    private static final ExecutorService DELAYABLE_EXECUTOR = Executors.newCachedThreadPool(
+            new ThreadFactoryBuilder()
+                    .setDaemon( true )
+                    .setNameFormat( "Delayables executor - #%d" )
+                    .build()
+    );
+
+    private Set<Consumer<T>> tasks;
+    private AtomicBoolean fired;
+
+    private final Callback<T> callback;
+
+    public DelayableEvent(Callback<T> callback)
+    {
+        this.callback = callback;
+        this.tasks = new HashSet<>();
+        this.fired = new AtomicBoolean( false );
+    }
+
+    /**
+     * Adds a task to run for this event
+     *
+     * @param task task
+     */
+    public void addTask(Consumer<T> task)
+    {
+        Preconditions.checkState( !fired.get(), "Event %s already fired", toString() );
+        tasks.add( Preconditions.checkNotNull( task ) );
+    }
+
+    @Override
+    public void postCall()
+    {
+        if ( !fired.compareAndSet( false, true ) )
+        {
+            return;
+        }
+
+        if ( !tasks.isEmpty() )
+        {
+            DELAYABLE_EXECUTOR.execute( () ->
+            {
+                for ( Consumer<T> consumer : tasks )
+                {
+                    try
+                    {
+                        consumer.accept( (T) this );
+                    } catch ( Throwable t )
+                    {
+                        callback.done( null, t );
+                    }
+                }
+            } );
+
+            callback.done( (T) this, null );
+        } else
+        {
+            callback.done( (T) this, null );
+        }
+    }
+}
diff --git a/api/src/main/java/net/md_5/bungee/api/event/ServerConnectEvent.java b/api/src/main/java/net/md_5/bungee/api/event/ServerConnectEvent.java
index dd13f764a002fd050759552da7fee0d56ee99d1e..2060d867bc9c2e6cd0cede8d362d9451f74dc63b 100644
--- a/api/src/main/java/net/md_5/bungee/api/event/ServerConnectEvent.java
+++ b/api/src/main/java/net/md_5/bungee/api/event/ServerConnectEvent.java
@@ -4,10 +4,15 @@ import lombok.Data;
 import lombok.EqualsAndHashCode;
 import lombok.NonNull;
 import lombok.ToString;
+import net.md_5.bungee.api.Callback; // IvanCord
 import net.md_5.bungee.api.config.ServerInfo;
 import net.md_5.bungee.api.connection.ProxiedPlayer;
 import net.md_5.bungee.api.plugin.Cancellable;
+/* IvanCord start
 import net.md_5.bungee.api.plugin.Event;
+ */
+import com.mrivanplays.ivancord.api.event.DelayableEvent;
+// IvanCord end
 
 /**
  * Called when deciding to connect to a server. At the time when this event is
@@ -18,7 +23,7 @@ import net.md_5.bungee.api.plugin.Event;
 @Data
 @ToString(callSuper = false)
 @EqualsAndHashCode(callSuper = false)
-public class ServerConnectEvent extends Event implements Cancellable
+public class ServerConnectEvent extends DelayableEvent<ServerConnectEvent> implements Cancellable // IvanCord - delayable event
 {
 
     /**
@@ -36,14 +41,19 @@ public class ServerConnectEvent extends Event implements Cancellable
     private boolean cancelled;
     private final Reason reason;
 
+    // IvanCord start
+    /*
     @Deprecated
     public ServerConnectEvent(ProxiedPlayer player, ServerInfo target)
     {
         this( player, target, Reason.UNKNOWN );
     }
+     */
 
-    public ServerConnectEvent(ProxiedPlayer player, ServerInfo target, Reason reason)
+    public ServerConnectEvent(ProxiedPlayer player, ServerInfo target, Reason reason, Callback<ServerConnectEvent> callback)
     {
+        super( callback );
+        // IvanCord end
         this.player = player;
         this.target = target;
         this.reason = reason;
diff --git a/proxy/src/main/java/net/md_5/bungee/UserConnection.java b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
index 4442da503a4a12ac93b37dd4d02fcd3f2bd6cc4c..5a0ef6b7e7dbe612948d807d23c1518a274c9ac3 100644
--- a/proxy/src/main/java/net/md_5/bungee/UserConnection.java
+++ b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
@@ -335,100 +335,110 @@ public final class UserConnection implements ProxiedPlayer
         Preconditions.checkNotNull( request, "request" );
 
         final Callback<ServerConnectRequest.Result> callback = request.getCallback();
-        ServerConnectEvent event = new ServerConnectEvent( this, request.getTarget(), request.getReason() );
-        if ( bungee.getPluginManager().callEvent( event ).isCancelled() )
+        // IvanCord start - move the code bellow inside the event callback
+        Callback<ServerConnectEvent> sceCall = new Callback<ServerConnectEvent>()
         {
-            if ( callback != null )
-            {
-                callback.done( ServerConnectRequest.Result.EVENT_CANCEL, null );
-            }
-
-            if ( getServer() == null && !ch.isClosing() )
-            {
-                throw new IllegalStateException( "Cancelled ServerConnectEvent with no server or disconnect." );
-            }
-            return;
-        }
 
-        final BungeeServerInfo target = (BungeeServerInfo) event.getTarget(); // Update in case the event changed target
-
-        if ( getServer() != null && Objects.equals( getServer().getInfo(), target ) )
-        {
-            if ( callback != null )
-            {
-                callback.done( ServerConnectRequest.Result.ALREADY_CONNECTED, null );
-            }
-            else // IvanCord - fix dumb connection message behaviour
-            sendMessage( bungee.getTranslation( "already_connected" ) );
-            return;
-        }
-        if ( pendingConnects.contains( target ) )
-        {
-            if ( callback != null )
-            {
-                callback.done( ServerConnectRequest.Result.ALREADY_CONNECTING, null );
-            }
-            else // IvanCord - fix dumb connection message behaviour
-            sendMessage( bungee.getTranslation( "already_connecting" ) );
-            return;
-        }
-
-        pendingConnects.add( target );
-
-        ChannelInitializer initializer = new ChannelInitializer()
-        {
-            @Override
-            protected void initChannel(Channel ch) throws Exception
-            {
-                PipelineUtils.BASE.initChannel( ch );
-                ch.pipeline().addAfter( PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion(), bungee.getConfig().isAllowEmptyPackets() ) ); // Waterfall
-                ch.pipeline().addAfter( PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
-                ch.pipeline().get( HandlerBoss.class ).setHandler( new ServerConnector( bungee, UserConnection.this, target ) );
-            }
-        };
-        ChannelFutureListener listener = new ChannelFutureListener()
-        {
             @Override
-            @SuppressWarnings("ThrowableResultIgnored")
-            public void operationComplete(ChannelFuture future) throws Exception
+            public void done(ServerConnectEvent result, Throwable error)
             {
-                if ( callback != null )
+                if ( result.isCancelled() )
                 {
-                    callback.done( ( future.isSuccess() ) ? ServerConnectRequest.Result.SUCCESS : ServerConnectRequest.Result.FAIL, future.cause() );
+                    if ( callback != null )
+                    {
+                        callback.done( ServerConnectRequest.Result.EVENT_CANCEL, null );
+                    }
+                    if ( getServer() == null && !ch.isClosing() )
+                    {
+                        throw new IllegalStateException( "Cancelled ServerConnectEvent with no server or disconnect." );
+                    }
+                    return;
                 }
+                final BungeeServerInfo target = (BungeeServerInfo) result.getTarget(); // Update in case the event changed target
 
-                if ( !future.isSuccess() )
+                if ( getServer() != null && Objects.equals( getServer().getInfo(), target ) )
                 {
-                    future.channel().close();
-                    pendingConnects.remove( target );
-
-                    ServerInfo def = updateAndGetNextServer( target );
-                    if ( request.isRetry() && def != null && ( getServer() == null || def != getServer().getInfo() ) )
+                    if ( callback != null )
+                    {
+                        callback.done( ServerConnectRequest.Result.ALREADY_CONNECTED, null );
+                    } else
                     {
-                        sendMessage( bungee.getTranslation( "fallback_lobby" ) );
-                        connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK, request.getConnectTimeout() ); // Waterfall
-                    } else if ( dimensionChange )
+                        sendMessage( bungee.getTranslation( "already_connected" ) );
+                    }
+                    return;
+                }
+                if ( pendingConnects.contains( target ) )
+                {
+                    if ( callback != null )
                     {
-                        disconnect( bungee.getTranslation( "fallback_kick", future.cause().getClass().getName() ) );
+                        callback.done( ServerConnectRequest.Result.ALREADY_CONNECTING, null );
                     } else
                     {
-                        sendMessage( bungee.getTranslation( "fallback_kick", future.cause().getClass().getName() ) );
+                        sendMessage( bungee.getTranslation( "already_connecting" ) );
                     }
+                    return;
                 }
+
+                pendingConnects.add( target );
+
+                ChannelInitializer initializer = new ChannelInitializer()
+                {
+                    @Override
+                    protected void initChannel(Channel ch) throws Exception
+                    {
+                        PipelineUtils.BASE.initChannel( ch );
+                        ch.pipeline().addAfter( PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion(), bungee.getConfig().isAllowEmptyPackets() ) ); // Waterfall
+                        ch.pipeline().addAfter( PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
+                        ch.pipeline().get( HandlerBoss.class ).setHandler( new ServerConnector( bungee, UserConnection.this, target ) );
+                    }
+                };
+                ChannelFutureListener listener = new ChannelFutureListener()
+                {
+                    @Override
+                    @SuppressWarnings("ThrowableResultIgnored")
+                    public void operationComplete(ChannelFuture future) throws Exception
+                    {
+                        if ( callback != null )
+                        {
+                            callback.done( ( future.isSuccess() ) ? ServerConnectRequest.Result.SUCCESS : ServerConnectRequest.Result.FAIL, future.cause() );
+                        }
+
+                        if ( !future.isSuccess() )
+                        {
+                            future.channel().close();
+                            pendingConnects.remove( target );
+
+                            ServerInfo def = updateAndGetNextServer( target );
+                            if ( request.isRetry() && def != null && ( getServer() == null || def != getServer().getInfo() ) )
+                            {
+                                sendMessage( bungee.getTranslation( "fallback_lobby" ) );
+                                connect( def, null, true, ServerConnectEvent.Reason.LOBBY_FALLBACK, request.getConnectTimeout() ); // Waterfall
+                            } else if ( dimensionChange )
+                            {
+                                disconnect( bungee.getTranslation( "fallback_kick", future.cause().getClass().getName() ) );
+                            } else
+                            {
+                                sendMessage( bungee.getTranslation( "fallback_kick", future.cause().getClass().getName() ) );
+                            }
+                        }
+                    }
+                };
+                Bootstrap b = new Bootstrap()
+                        .channel( PipelineUtils.getChannel() )
+                        .group( ch.getHandle().eventLoop() )
+                        .handler( initializer )
+                        .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
+                        .remoteAddress( target.getAddress() );
+                // Windows is bugged, multi homed users will just have to live with random connecting IPs
+                if ( getPendingConnection().getListener().isSetLocalAddress() && !PlatformDependent.isWindows() )
+                {
+                    b.localAddress( getPendingConnection().getListener().getHost().getHostString(), 0 );
+                }
+                b.connect().addListener( listener );
             }
         };
-        Bootstrap b = new Bootstrap()
-                .channel( PipelineUtils.getChannel() )
-                .group( ch.getHandle().eventLoop() )
-                .handler( initializer )
-                .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
-                .remoteAddress( target.getAddress() );
-        // Windows is bugged, multi homed users will just have to live with random connecting IPs
-        if ( getPendingConnection().getListener().isSetLocalAddress() && !PlatformDependent.isWindows() )
-        {
-            b.localAddress( getPendingConnection().getListener().getHost().getHostString(), 0 );
-        }
-        b.connect().addListener( listener );
+        bungee.getPluginManager().callEvent( new ServerConnectEvent( this, request.getTarget(), request.getReason(), sceCall ) );
+        // IvanCord end
     }
 
     @Override
