From 58ee66db591b16ef263e3f495a679cff8fd11d71 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <pekov.ivan@abv.bg>
Date: Sat, 20 Jul 2019 11:23:03 +0300
Subject: [PATCH] Command framework for multiple command handling

Adds a command framework, which is lambda-friendly and multi-command
handling friendly in one class.

diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/ICommand.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/ICommand.java
new file mode 100644
index 00000000..c54ca5fb
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/ICommand.java
@@ -0,0 +1,34 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.collect.ImmutableList;
+import net.md_5.bungee.api.CommandSender;
+
+/**
+ * Represents a command
+ */
+@FunctionalInterface
+public interface ICommand
+{
+
+    /**
+     * Executes the command specified.
+     *
+     * @param sender the sender of the command
+     * @param alias the alias of which the command was triggered
+     * @param args command arguments
+     */
+    void execute(CommandSender sender, String alias, String[] args);
+
+    /**
+     * Tab completes the command specified
+     *
+     * @param sender the sender of the tab completion
+     * @param alias the alias of which the tab completion was triggered
+     * @param args tab complete arguments
+     * @return a iterable of string matches for the given argument
+     */
+    default Iterable<String> tabComplete(CommandSender sender, String alias, String[] args)
+    {
+        return ImmutableList.of();
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/IvanCordCommandManager.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/IvanCordCommandManager.java
new file mode 100644
index 00000000..b1de6520
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/IvanCordCommandManager.java
@@ -0,0 +1,215 @@
+package com.mrivanplays.ivancord.api.command;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Optional;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.Multimap;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.api.plugin.TabExecutor;
+
+/**
+ * Represents a command manager
+ */
+public final class IvanCordCommandManager
+{
+
+    private ProxyServer proxy;
+    private Multimap<Plugin, String> registeredCommandAliases = HashMultimap.create();
+
+    public IvanCordCommandManager(ProxyServer proxy)
+    {
+        this.proxy = proxy;
+    }
+
+    /**
+     * Registers a command
+     *
+     * @param plugin                the plugin bind to
+     * @param command               the command
+     * @param commandsExecutedNames all commands, executed in this command
+     */
+    public void registerCommand(Plugin plugin, ICommand command, String... commandsExecutedNames)
+    {
+        Preconditions.checkNotNull( plugin, "plugin" );
+        Preconditions.checkNotNull( command, "command" );
+        Preconditions.checkNotNull( commandsExecutedNames, "Command names cannot be null" );
+        for ( String alias : commandsExecutedNames )
+        {
+            if ( registeredCommandAliases.containsKey( plugin ) )
+            {
+                if ( registeredCommandAliases.get( plugin ).contains( alias ) )
+                {
+                    continue;
+                }
+            }
+            registeredCommandAliases.put( plugin, alias );
+            proxy.getPluginManager().registerCommand( plugin, new CommandWrapper( command, alias ) );
+        }
+    }
+
+    /**
+     * Unregisters a command
+     *
+     * @param commandName the command's name or alias you wish to unregister
+     * @return success state of the unregister
+     */
+    public boolean unregisterCommand(String commandName)
+    {
+        Preconditions.checkNotNull( commandName, "commandName" );
+        Preconditions.checkArgument( !commandName.isEmpty(), "Command name cannot be empty" );
+        if ( !registeredCommandAliases.values().contains( commandName ) )
+        {
+            return false;
+        }
+        Plugin plugin = getPlugin( commandName );
+        if ( plugin == null )
+        {
+            return false;
+        }
+        registeredCommandAliases.remove( plugin, commandName );
+        proxy.getPluginManager().getCommand( commandName )
+                .ifPresent( command -> proxy.getPluginManager().unregisterCommand( command ) );
+        return true;
+    }
+
+    /**
+     * Unregisters all commands for the specified plugin, registered from here.
+     *
+     * @param plugin the plugin for which you want to unregister the commands
+     * @return success state of the unregister
+     */
+    public boolean unregisterCommands(Plugin plugin)
+    {
+        Preconditions.checkNotNull( plugin, "plugin" );
+        Collection<String> commands = registeredCommandAliases.get( plugin );
+        registeredCommandAliases.removeAll( plugin );
+        if ( commands.isEmpty() )
+        {
+            return false;
+        }
+        for ( String alias : commands )
+        {
+            proxy.getPluginManager().getCommand( alias )
+                    .ifPresent( command -> proxy.getPluginManager().unregisterCommand( command ) );
+        }
+        return true;
+    }
+
+    /**
+     * Gets the command aliases the specified plugin has registered.
+     *
+     * @param plugin the plugin of which you want to get the registered command aliases
+     * @return command aliases or empty list if none
+     */
+    public Collection<String> getCommandAliases(Plugin plugin)
+    {
+        Preconditions.checkNotNull( plugin, "plugin" );
+        if ( !registeredCommandAliases.containsKey( plugin ) )
+        {
+            return Collections.emptyList();
+        }
+        return ImmutableList.copyOf( registeredCommandAliases.get( plugin ) );
+    }
+
+    /**
+     * Gets the commands the specified plugin has registered from here.
+     *
+     * @param plugin the plugin of which you want to get the commands of
+     * @return commands
+     * @deprecated in favour of {@link #getCommandMap(Plugin)}
+     */
+    @Deprecated
+    public Collection<ICommand> getCommands(Plugin plugin)
+    {
+        return getCommandMap( plugin ).keySet();
+    }
+
+    /**
+     * Gets the commands the specified plugin has registered from here.
+     *
+     * @param plugin the plugin of which you want to get the commands of
+     * @return a command multimap with a command for key and collection of string for its names.
+     * May be empty if the plugin had no registered commands from here
+     */
+    public Multimap<ICommand, String> getCommandMap(Plugin plugin)
+    {
+        Preconditions.checkNotNull( plugin, "plugin" );
+        Multimap<ICommand, String> commands = HashMultimap.create();
+        Collection<String> commandAliases = getCommandAliases( plugin );
+        if ( commandAliases.isEmpty() )
+        {
+            return ImmutableMultimap.of();
+        }
+        for ( String alias : commandAliases )
+        {
+            Optional<Command> bungeeCommand = proxy.getPluginManager().getCommand( alias );
+            if ( !bungeeCommand.isPresent() )
+            {
+                continue;
+            }
+            Command bungee = bungeeCommand.get();
+            if ( !( bungee instanceof CommandWrapper ) )
+            {
+                continue;
+            }
+            commands.put( ( (CommandWrapper) bungee ).getCommand(), alias );
+        }
+        return commands;
+    }
+
+    private Plugin getPlugin(String alias)
+    {
+        for ( Map.Entry<Plugin, String> entry : registeredCommandAliases.entries() )
+        {
+            if ( entry.getValue().toLowerCase().equalsIgnoreCase( alias.toLowerCase() ) )
+            {
+                return entry.getKey();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Represents a command wrapper between our {@link ICommand} and BungeeCord's {@link Command}
+     */
+    public static final class CommandWrapper extends Command implements TabExecutor
+    {
+
+        private String currentAlias;
+        private ICommand command;
+
+        public CommandWrapper(ICommand command, String currentAlias)
+        {
+            super( currentAlias );
+            this.command = command;
+            this.currentAlias = currentAlias;
+        }
+
+        @Override
+        public void execute(CommandSender sender, String[] args)
+        {
+            command.execute( sender, currentAlias, args );
+        }
+
+        @Override
+        public Iterable<String> onTabComplete(CommandSender sender, String[] args)
+        {
+            return command.tabComplete( sender, currentAlias, args );
+        }
+
+        public ICommand getCommand()
+        {
+            return command;
+        }
+    }
+
+}
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
index 61e99410..1eb8a79b 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
@@ -17,6 +17,7 @@ import net.md_5.bungee.api.plugin.PluginManager;
 import net.md_5.bungee.api.scheduler.TaskScheduler;
 
 import com.mrivanplays.ivancord.api.plugin.ServicesManager; // IvanCord
+import com.mrivanplays.ivancord.api.command.IvanCordCommandManager; // IvanCord
 
 public abstract class ProxyServer
 {
@@ -326,6 +327,13 @@ public abstract class ProxyServer
      */
     public abstract ServicesManager getServicesManager();
 
+    /**
+     * Gets the IvanCord commands' manager
+     *
+     * @return command manager of the IvanCord commands
+     */
+    public abstract IvanCordCommandManager getIvanCordCommandManager();
+
     // IvanCord end
 
 }
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
index 2b79cdae..4b80bcab 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
@@ -19,6 +19,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Optional; // IvanCord
 import java.util.Set;
 import java.util.Stack;
 import java.util.jar.JarEntry;
@@ -114,6 +115,9 @@ public class PluginManager
             while ( commandMap.values().remove( command ) );
             it.remove();
         }
+        // IvanCord start
+        proxy.getIvanCordCommandManager().unregisterCommands( plugin );
+        // IvanCord end
     }
 
     private Command getCommandIfEnabled(String commandName, CommandSender sender)
@@ -129,6 +133,25 @@ public class PluginManager
         return commandMap.get( commandLower );
     }
 
+    // IvanCord start - getCommand
+
+    /**
+     * Gets command by its name or alias.
+     *
+     * @param alias command alias or command name
+     * @return command optional
+     */
+    public Optional<Command> getCommand(String alias)
+    {
+        if ( proxy.getDisabledCommands().contains( alias.toLowerCase() ) )
+        {
+            return Optional.empty();
+        }
+        return Optional.ofNullable( commandMap.get( alias.toLowerCase() ) );
+    }
+
+    // IvanCord end
+
     /**
      * Checks if the command is registered and can possibly be executed by the
      * sender (without taking permissions into account).
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index 8b5841b8..12998fff 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -108,6 +108,7 @@ import com.mrivanplays.ivancord.ReconnectHandlerType;
 import com.mrivanplays.ivancord.modules.YamlReconnectHandler;
 import com.mrivanplays.ivancord.SimpleServicesManager;
 import com.mrivanplays.ivancord.api.plugin.ServicesManager;
+import com.mrivanplays.ivancord.api.command.IvanCordCommandManager;
 // IvanCord end
 
 /**
@@ -194,6 +195,8 @@ public class BungeeCord extends ProxyServer
     // IvanCord start
     @Getter
     private ServicesManager servicesManager;
+    @Getter
+    private IvanCordCommandManager ivanCordCommandManager;
     // IvanCord end
 
     {
@@ -314,6 +317,7 @@ public class BungeeCord extends ProxyServer
         pluginManager.detectPlugins( pluginsFolder );
 
         // IvanCord start
+        ivanCordCommandManager = new IvanCordCommandManager( this );
         servicesManager = new SimpleServicesManager();
         // IvanCord end
 
-- 
2.22.0.windows.1

