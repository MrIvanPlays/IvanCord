From 7eec796a8793184d0a3bd12e013077f58b613141 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <pekov.ivan@abv.bg>
Date: Fri, 14 Jun 2019 16:38:20 +0300
Subject: [PATCH] Add support for json configuration files


diff --git a/config/pom.xml b/config/pom.xml
index 32a005ff..d4f495bf 100644
--- a/config/pom.xml
+++ b/config/pom.xml
@@ -24,5 +24,12 @@
             <version>1.23</version>
             <scope>compile</scope>
         </dependency>
+        <!-- IvanCord - add gson -->
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <version>2.8.0</version>
+            <scope>provided</scope>
+        </dependency>
     </dependencies>
 </project>
diff --git a/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java b/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
index eece8870..24ed163f 100644
--- a/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
+++ b/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
@@ -12,17 +12,51 @@ public abstract class ConfigurationProvider
 {
 
     private static final Map<Class<? extends ConfigurationProvider>, ConfigurationProvider> providers = new HashMap<>();
+    // IvanCord start
+    private static JsonConfiguration providerPrettyJson;
+    private static JsonConfiguration providerNonPrettyJson;
+    // IvanCord end
 
     static
     {
         providers.put( YamlConfiguration.class, new YamlConfiguration() );
+        // IvanCord start
+        ConfigurationProvider.providerPrettyJson = new JsonConfiguration( true );
+        ConfigurationProvider.providerNonPrettyJson = new JsonConfiguration( false );
+        // IvanCord end
     }
 
     public static ConfigurationProvider getProvider(Class<? extends ConfigurationProvider> provider)
     {
+        // IvanCord start
+        if ( provider.isAssignableFrom( JsonConfiguration.class ) )
+        {
+            return getJsonConfigurationProvider( true );
+        }
+        // IvanCord end
         return providers.get( provider );
     }
 
+    // IvanCord start
+
+    /**
+     * Gets a json configuration provider.
+     *
+     * @param prettyPrinting should the typen json when saving be readable for humans, or no?
+     * @return json configuration provider
+     */
+    public static ConfigurationProvider getJsonConfigurationProvider(boolean prettyPrinting)
+    {
+        if ( prettyPrinting )
+        {
+            return providerPrettyJson;
+        } else
+        {
+            return providerNonPrettyJson;
+        }
+    }
+    // IvanCord end
+
     /*------------------------------------------------------------------------*/
     public abstract void save(Configuration config, File file) throws IOException;
 
diff --git a/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java b/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java
new file mode 100644
index 00000000..cef497f9
--- /dev/null
+++ b/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java
@@ -0,0 +1,116 @@
+package net.md_5.bungee.config;
+// IvanCord start
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import com.google.common.base.Charsets;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+
+public class JsonConfiguration extends ConfigurationProvider
+{
+
+    private Gson gson;
+    private Type mapType;
+
+    public JsonConfiguration(boolean prettyPrinting)
+    {
+        this.mapType = new TypeToken<Map<String, Object>>(){}.getType();
+        if ( prettyPrinting )
+        {
+            gson = new GsonBuilder().registerTypeAdapter( mapType, new MapSerializer() ).setPrettyPrinting().create();
+        } else
+        {
+            gson = new GsonBuilder().registerTypeAdapter( mapType, new MapSerializer() ).create();
+        }
+    }
+
+    @Override
+    public void save(Configuration config, File file) throws IOException
+    {
+        try ( Writer writer = new OutputStreamWriter( new FileOutputStream( file ), Charsets.UTF_8 ) )
+        {
+            save( config, writer );
+        }
+    }
+
+    @Override
+    public void save(Configuration config, Writer writer)
+    {
+        gson.toJson( config.self, mapType, writer );
+    }
+
+    @Override
+    public Configuration load(File file) throws IOException
+    {
+        return load( file, null );
+    }
+
+    @Override
+    public Configuration load(File file, Configuration defaults) throws IOException
+    {
+        try ( FileReader reader = new FileReader( file ) )
+        {
+            return load( reader, defaults );
+        }
+    }
+
+    @Override
+    public Configuration load(Reader reader)
+    {
+        return load( reader, null );
+    }
+
+    @Override
+    public Configuration load(Reader reader, Configuration defaults)
+    {
+        Map<String, Object> map = gson.fromJson( reader, mapType );
+        if ( map == null )
+        {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration( map, defaults );
+    }
+
+    @Override
+    public Configuration load(InputStream is)
+    {
+        return load( is, null );
+    }
+
+    @Override
+    public Configuration load(InputStream is, Configuration defaults)
+    {
+        return load( new InputStreamReader( is ), defaults );
+    }
+
+    @Override
+    public Configuration load(String string)
+    {
+        return load( string, null );
+    }
+
+    @Override
+    public Configuration load(String string, Configuration defaults)
+    {
+        Map<String, Object> map = gson.fromJson( string, mapType );
+        if ( map == null )
+        {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration( map, defaults );
+    }
+}
+// IvanCord end
\ No newline at end of file
diff --git a/config/src/main/java/net/md_5/bungee/config/MapSerializer.java b/config/src/main/java/net/md_5/bungee/config/MapSerializer.java
new file mode 100644
index 00000000..8a9e32d5
--- /dev/null
+++ b/config/src/main/java/net/md_5/bungee/config/MapSerializer.java
@@ -0,0 +1,85 @@
+package net.md_5.bungee.config;
+// IvanCord start
+
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.reflect.TypeToken;
+
+public class MapSerializer implements JsonSerializer<Map<String, Object>>, JsonDeserializer<Map<String, Object>>
+{
+
+    @Override
+    public Map<String, Object> deserialize(JsonElement element, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
+    {
+        Map<String, Object> map = new LinkedHashMap<>();
+        List<Map.Entry<String, JsonElement>> primitives = element.getAsJsonObject().entrySet()
+                .stream()
+                .filter( entry -> entry.getValue().isJsonPrimitive() )
+                .collect( Collectors.toList() );
+        primitives.forEach( entry ->
+        {
+            String key = entry.getKey();
+            JsonPrimitive value = entry.getValue().getAsJsonPrimitive();
+            if ( value.isBoolean() )
+            {
+                map.put( key, value.getAsBoolean() );
+            }
+            if ( value.isNumber() )
+            {
+                map.put( key, value.getAsNumber() );
+            }
+            if ( value.isString() )
+            {
+                map.put( key, value.getAsString() );
+            }
+            if ( value.isJsonObject() )
+            {
+                Map<String, Object> map2 = context.deserialize( value.getAsJsonObject(), new TypeToken<Map<String, Object>>(){}.getType() );
+                map.put( key, map2 );
+            }
+        } );
+        return map;
+    }
+
+    @Override
+    public JsonElement serialize(Map<String, Object> src, Type typeOfSrc, JsonSerializationContext context)
+    {
+        JsonObject object = new JsonObject();
+        for ( Map.Entry<String, Object> entry : src.entrySet() )
+        {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            if ( value instanceof Boolean )
+            {
+                object.addProperty( key, (Boolean) value );
+            }
+            if ( value instanceof String )
+            {
+                object.addProperty( key, String.valueOf( value ) );
+            }
+            if ( value instanceof Number )
+            {
+                object.addProperty( key, (Number) value );
+            }
+            if ( value instanceof Map )
+            {
+                Map map = (Map) value;
+                object.add( key, context.serialize( map, JsonObject.class ) );
+            }
+        }
+        return object;
+    }
+}
+// IvanCord end
\ No newline at end of file
-- 
2.21.0.windows.1

