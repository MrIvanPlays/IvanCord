From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ivan Pekov <ivan@mrivanplays.com>
Date: Thu, 3 Sep 2020 16:11:03 +0300
Subject: [PATCH] Brigadier command api


diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..158fef8dbd9e616c2bfebbfecde662bca22390be
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/Brigadier2LegacyCommandTransformer.java
@@ -0,0 +1,46 @@
+package com.mrivanplays.ivancord.api.command;
+
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.TabExecutor;
+
+class Brigadier2LegacyCommandTransformer
+{
+
+    static Command transform(CommandDispatcherProxy dispatcher, BrigadierCommand command)
+    {
+        return new DummyCommand( dispatcher, command );
+    }
+
+    private static class DummyCommand extends Command implements TabExecutor
+    {
+
+        private final CommandDispatcherProxy dispatcher;
+        private final BrigadierCommand command;
+
+        public DummyCommand(CommandDispatcherProxy dispatcher, BrigadierCommand command)
+        {
+            super( command.getCommandNode().getName(), null, command.getAliases() );
+            this.dispatcher = dispatcher;
+            this.command = command;
+        }
+
+        @Override
+        public void execute(CommandSender sender, String alias, String[] args)
+        {
+            dispatcher.dispatch( sender, alias + String.join( " ", args ) );
+        }
+
+        @Override
+        public boolean hasPermission(CommandSender sender)
+        {
+            return command.getCommandNode().getRequirement() == null || command.getCommandNode().getRequirement().test( sender );
+        }
+
+        @Override
+        public Iterable<String> onTabComplete(CommandSender sender, String alias, String[] args)
+        {
+            return dispatcher.complete( sender, alias + String.join( " ", args ), false );
+        }
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c4769518b0e957b5365983434adcfca81dc51115
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/BrigadierCommand.java
@@ -0,0 +1,43 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Preconditions;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import lombok.AllArgsConstructor;
+import lombok.Getter;
+import lombok.NonNull;
+import lombok.RequiredArgsConstructor;
+import lombok.Setter;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Plugin;
+
+@RequiredArgsConstructor
+@AllArgsConstructor
+@Getter
+@Setter
+public final class BrigadierCommand
+{
+
+    /**
+     * A special return value saying to forward the command to the server.
+     */
+    public static int FORWARD = 0xF448224;
+
+    private final Plugin plugin;
+    @NonNull
+    private final LiteralCommandNode<CommandSender> commandNode;
+    private String[] aliases = null;
+
+    public BrigadierCommand(Plugin plugin, LiteralArgumentBuilder<CommandSender> argumentBuilder)
+    {
+        Preconditions.checkNotNull( argumentBuilder, "argumentBuilder" );
+        this.plugin = plugin;
+        this.commandNode = argumentBuilder.build();
+    }
+
+    public BrigadierCommand(Plugin plugin, LiteralArgumentBuilder<CommandSender> argumentBuilder, String... aliases)
+    {
+        this( plugin, argumentBuilder );
+        this.aliases = aliases;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6bb3fb31359d5bb73c18b1e3d0abc9671ff5327
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/CommandDispatcherProxy.java
@@ -0,0 +1,512 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Table;
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.ParseResults;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestion;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import com.mrivanplays.ivancord.api.command.message.BungeeMessage;
+import com.mrivanplays.ivancord.api.util.Constants;
+import io.github.waterfallmc.waterfall.event.ProxyExceptionEvent;
+import io.github.waterfallmc.waterfall.exception.ProxyCommandException;
+import io.github.waterfallmc.waterfall.exception.ProxyTabCompleteException;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.connection.ProxiedPlayer;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.api.plugin.PluginManager;
+
+public final class CommandDispatcherProxy
+{
+
+    private final PluginManager pluginManager;
+    private final ProxyServer proxy; // easier access
+
+    private final CommandDispatcher<CommandSender> dispatcher = new CommandDispatcher<>();
+    private final Table<String, String, Command> commandsTable = HashBasedTable.create();
+    private final Lock commandsLock = new ReentrantLock();
+
+    private Collection<Map.Entry<String, Command>> cachedCommands;
+
+    public CommandDispatcherProxy(PluginManager pluginManager, ProxyServer proxy)
+    {
+        this.pluginManager = pluginManager;
+        this.proxy = proxy;
+    }
+
+    public void register(Plugin plugin, Command command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        register( Legacy2BrigadierCommandTransformer.transform( plugin, command ), command );
+    }
+
+    private void register(BrigadierCommand brigadierCommand, Command bungeeCommand)
+    {
+        CommandNode<CommandSender> base = brigadierCommand.getCommandNode();
+        dispatcher.getRoot().addChild( base );
+        String main;
+        if ( brigadierCommand.getPlugin() == null )
+        {
+            main = "BungeeSpecificCommand";
+        } else
+        {
+            main = brigadierCommand.getPlugin().getDescription().getMain();
+        }
+        commandsLock.lock();
+        try
+        {
+            commandsTable.put( main, base.getName().toLowerCase(), bungeeCommand );
+            if ( brigadierCommand.getAliases() != null && brigadierCommand.getAliases().length != 0 )
+            {
+                for ( String alias : brigadierCommand.getAliases() )
+                {
+                    alias = alias.toLowerCase();
+                    // using .redirect doesn't work properly
+                    // see https://github.com/Mojang/brigadier/issues/46
+                    LiteralCommandNode<CommandSender> redirect = LiteralArgumentBuilder.<CommandSender>literal( alias )
+                        .requires( base.getRequirement() )
+                        .forward( base.getRedirect(), base.getRedirectModifier(), base.isFork() )
+                        .executes( base.getCommand() )
+                        .build();
+                    for ( CommandNode<CommandSender> child : base.getChildren() )
+                    {
+                        redirect.addChild( child );
+                    }
+                    dispatcher.getRoot().addChild( redirect );
+                    commandsTable.put( main, alias, bungeeCommand );
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public void register(BrigadierCommand command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        register( command, Brigadier2LegacyCommandTransformer.transform( this, command ) );
+    }
+
+    public void unregister(Command command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        String nameLower = command.getName().toLowerCase();
+        commandsLock.lock();
+        try
+        {
+            for ( Plugin plugin : pluginManager.getPlugins() )
+            {
+                String main = plugin.getDescription().getMain();
+                if ( commandsTable.containsRow( main ) )
+                {
+                    Map<String, Command> commands = commandsTable.row( main );
+                    if ( commands.containsKey( nameLower ) || containsAny( commands, command.getAliases() ) )
+                    {
+                        CommandNode<CommandSender> node = dispatcher.getRoot().getChild( nameLower );
+                        if ( node != null )
+                        {
+                            commandsTable.remove( main, nameLower );
+                            dispatcher.getRoot().getChildren().remove( node );
+                            if ( command.getAliases() != null && command.getAliases().length != 0 )
+                            {
+                                for ( String alias : command.getAliases() )
+                                {
+                                    alias = alias.toLowerCase();
+                                    CommandNode<CommandSender> aliasNode = dispatcher.getRoot().getChild( alias );
+                                    if ( aliasNode != null )
+                                    {
+                                        commandsTable.remove( main, alias );
+                                        dispatcher.getRoot().getChildren().remove( aliasNode );
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    private boolean containsAny(Map<String, Command> col, String[] array)
+    {
+        if ( array == null || array.length == 0 )
+        {
+            return false;
+        }
+        for ( String s : array )
+        {
+            if ( col.containsKey( s.toLowerCase() ) )
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean isExecutable(String commandName, CommandSender sender)
+    {
+        if ( commandName == null || commandName.isEmpty() )
+        {
+            return false;
+        }
+        Preconditions.checkNotNull( sender, "sender" );
+        commandName = commandName.toLowerCase();
+        if ( dispatcher.getRoot().getChild( commandName ) != null )
+        {
+            return !( sender instanceof ProxiedPlayer ) || proxy.getDisabledCommands() == null ||  !proxy.getDisabledCommands().contains( commandName );
+        }
+        return false;
+    }
+
+    public void unregister(BrigadierCommand command)
+    {
+        Preconditions.checkNotNull( command, "command" );
+        dispatcher.getRoot().getChildren().remove( command.getCommandNode() );
+        commandsLock.lock();
+        try
+        {
+            String main;
+            if ( command.getPlugin() == null )
+            {
+                main = "BungeeSpecificCommand";
+            } else
+            {
+                main = command.getPlugin().getDescription().getMain();
+            }
+            commandsTable.remove( main, command.getCommandNode().getName().toLowerCase() );
+            if ( command.getAliases() != null && command.getAliases().length != 0 )
+            {
+                for ( String alias : command.getAliases() )
+                {
+                    alias = alias.toLowerCase();
+                    CommandNode<CommandSender> node = dispatcher.getRoot().getChild( alias );
+                    if ( node != null )
+                    {
+                        dispatcher.getRoot().getChildren().remove( node );
+                        commandsTable.remove( main, alias );
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    public void unregisterAll(Plugin plugin)
+    {
+        String main;
+        if ( plugin == null )
+        {
+            main = "BungeeSpecificCommand";
+        } else
+        {
+            main = plugin.getDescription().getMain();
+        }
+        commandsLock.lock();
+        try
+        {
+            Map<String, Command> commands = commandsTable.rowMap().remove( main );
+            if ( commands != null )
+            {
+                for ( String alias : commands.keySet() )
+                {
+                    CommandNode<CommandSender> node = dispatcher.getRoot().getChild( alias.toLowerCase() );
+                    if ( node != null )
+                    {
+                        dispatcher.getRoot().getChildren().remove( node );
+                    }
+                }
+            }
+        } finally
+        {
+            commandsLock.unlock();
+        }
+        cachedCommands = null;
+    }
+
+    public int dispatch(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() )
+        {
+            return 0;
+        }
+        if ( input.indexOf( ' ' ) == -1 )
+        {
+            if ( !isExecutable( input.toLowerCase(), sender ) )
+            {
+                return 0;
+            }
+        } else
+        {
+            int firstSpace = input.indexOf( ' ' );
+            String commandName = input.substring( 0, firstSpace );
+            if ( !isExecutable( commandName, sender ) )
+            {
+                return 0;
+            }
+        }
+        try
+        {
+            int result = dispatcher.execute( input, sender );
+            if ( result == BrigadierCommand.FORWARD )
+            {
+                // that's of course, a lie for the dispatchCommand's return value
+                // but we can't just break bungee api so im sorry for lying :(
+                return 0;
+            }
+            return 1;
+        } catch ( CommandSyntaxException e )
+        {
+            if ( sender instanceof ProxiedPlayer )
+            {
+                int firstSpace = input.indexOf( ' ' );
+                String commandName = firstSpace == -1 ? input.toLowerCase() : input.substring( 0, firstSpace );
+                CommandNode<CommandSender> node = dispatcher.getRoot().getChild( commandName.toLowerCase() );
+                Command legacyCommand = getCommand( commandName.toLowerCase() );
+                if ( node != null && node.getRequirement() != null )
+                {
+                    try
+                    {
+                        if ( !node.getRequirement().test( sender ) )
+                        {
+                            sender.sendMessage( TextComponent.fromLegacyText( legacyCommand.getPermissionMessage() != null ? legacyCommand.getPermissionMessage() : proxy.getTranslation( "no_permission" ) ) );
+                            return 2;
+                        }
+                    } catch ( Throwable e1 )
+                    {
+                        // plugins make me cry
+                        sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_executing" ) ) );
+                        proxy.getLogger().log( Level.WARNING, "Requirement test for command node " + node.getName() + " encountered an exception", e1 );
+
+                        String[] args = Constants.EMPTY_ARRAY;
+                        if ( firstSpace != -1 )
+                        {
+                            String[] inputSplit = input.split( " " );
+                            args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                        }
+                        pluginManager.callEvent( new ProxyExceptionEvent( new ProxyCommandException( e1, legacyCommand, sender, args ) ) );
+                        return 2;
+                    }
+                }
+            }
+            sender.sendMessage( BungeeMessage.convertSyntaxException( e ) );
+            return 2;
+        } catch ( Throwable e )
+        {
+            // plugins being plugins
+            sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_executing" ) ) );
+            proxy.getLogger().log( Level.WARNING, "Error in dispatching command", e );
+
+            String commandName = input.toLowerCase();
+            String[] args = Constants.EMPTY_ARRAY;
+            if ( input.indexOf( ' ' ) != -1 )
+            {
+                String[] inputSplit = input.split( " " );
+                commandName = inputSplit[0].toLowerCase();
+                args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+            }
+            Command command = getCommand( commandName );
+            pluginManager.callEvent( new ProxyExceptionEvent( new ProxyCommandException( e, command, sender, args ) ) );
+            return 1;
+        }
+    }
+
+    public Command getCommand(String commandName)
+    {
+        Preconditions.checkNotNull( commandName, "commandName" );
+        commandName = commandName.toLowerCase();
+        commandsLock.lock();
+        try
+        {
+            for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+            {
+                if ( cell.getColumnKey() != null && cell.getColumnKey().equalsIgnoreCase( commandName ) )
+                {
+                    return cell.getValue();
+                }
+            }
+            return null;
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public List<String> complete(CommandSender sender, String input, boolean check)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( check )
+        {
+            if ( input == null || input.isEmpty() || input.indexOf( ' ' ) == -1 )
+            {
+                return Collections.emptyList();
+            }
+            if ( !isExecutable( input.substring( 0, input.indexOf( ' ' ) ), sender ) )
+            {
+                return Collections.emptyList();
+            }
+        }
+        try
+        {
+            ParseResults<CommandSender> results = dispatcher.parse( input, sender );
+            return dispatcher.getCompletionSuggestions( results )
+                .thenApply( suggestions -> Lists.transform( suggestions.getList(), Suggestion::getText ) ).join();
+        } catch ( Throwable e )
+        {
+            // plugins being plugins
+            sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_completing" ) ) );
+            proxy.getLogger().log( Level.WARNING, "Error in dispatching command", e );
+
+            String[] inputSplit = input.split( " " );
+            String commandName = inputSplit[0].toLowerCase();
+            String[] args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+            Command command = getCommand( commandName );
+            pluginManager.callEvent( new ProxyExceptionEvent( new ProxyTabCompleteException( e, command, sender, args ) ) );
+            return Collections.emptyList();
+        }
+    }
+
+    public CompletableFuture<Suggestions> complete(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() || input.indexOf( ' ' ) == -1 )
+        {
+            return Suggestions.empty();
+        }
+        String commandName = input.substring( 0, input.indexOf( ' ' ) );
+        if ( !isExecutable( commandName, sender ) )
+        {
+            return Suggestions.empty();
+        }
+        try
+        {
+            ParseResults<CommandSender> results = dispatcher.parse( input, sender );
+            return dispatcher.getCompletionSuggestions( results );
+        } catch ( Throwable e )
+        {
+            // plugins being plugins
+            sender.sendMessage( TextComponent.fromLegacyText( proxy.getTranslation( "internal_error_completing" ) ) );
+            proxy.getLogger().log( Level.WARNING, "Error in dispatching command", e );
+
+            String[] args = Constants.EMPTY_ARRAY;
+            if ( input.indexOf( ' ' ) != -1 )
+            {
+                String[] inputSplit = input.split( " " );
+                args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+            }
+            Command command = getCommand( commandName );
+            pluginManager.callEvent( new ProxyExceptionEvent( new ProxyTabCompleteException( e, command, sender, args ) ) );
+            return Suggestions.empty();
+        }
+    }
+
+    public List<String> completeWithNames(CommandSender sender, String input)
+    {
+        Preconditions.checkNotNull( sender, "sender" );
+        if ( input == null || input.isEmpty() )
+        {
+            return Collections.emptyList();
+        }
+        if ( input.indexOf( ' ' ) == -1 && !isExecutable( input, sender ) )
+        {
+            return Collections.emptyList();
+        } else if ( input.indexOf( ' ' ) != -1 )
+        {
+            if ( !isExecutable( input.substring( 0, input.indexOf( ' ' ) ), sender ) )
+            {
+                return Collections.emptyList();
+            }
+        }
+        List<String> ret = new ArrayList<>();
+        if ( input.indexOf( ' ' ) == -1 )
+        {
+            input = input.toLowerCase();
+            commandsLock.lock();
+            try
+            {
+                for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+                {
+                    String name = cell.getColumnKey();
+                    if ( name != null )
+                    {
+                        name = name.toLowerCase();
+                        CommandNode<CommandSender> brigadierNode = dispatcher.getRoot().getChild( name );
+                        if ( brigadierNode != null && isExecutable( name, sender ) && input.startsWith( name ) )
+                        {
+                            if ( brigadierNode.getRequirement() == null || brigadierNode.getRequirement().test( sender ) )
+                            {
+                                ret.add( name );
+                            }
+                        }
+                    }
+                }
+            } finally
+            {
+                commandsLock.unlock();
+            }
+        } else
+        {
+            ret.addAll( complete( sender, input, false ) );
+        }
+        return ret;
+    }
+
+    public Collection<Map.Entry<String, Command>> getCommands()
+    {
+        if ( cachedCommands != null )
+        {
+            return Collections.unmodifiableCollection( cachedCommands );
+        }
+        commandsLock.lock();
+        try
+        {
+            Collection<Map.Entry<String, Command>> col = new ArrayList<>();
+            for ( Table.Cell<String, String, Command> cell : commandsTable.cellSet() )
+            {
+                if ( cell.getColumnKey() != null && cell.getValue() != null )
+                {
+                    col.add( new AbstractMap.SimpleEntry<>( cell.getColumnKey(), cell.getValue() ) );
+                }
+            }
+            cachedCommands = col;
+            return Collections.unmodifiableCollection( col );
+        } finally
+        {
+            commandsLock.unlock();
+        }
+    }
+
+    public Collection<CommandNode<CommandSender>> getBrigadierCommands()
+    {
+        return Collections.unmodifiableCollection( dispatcher.getRoot().getChildren() );
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java b/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c358613703df96101810aee906556c27d65d1358
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/command/Legacy2BrigadierCommandTransformer.java
@@ -0,0 +1,77 @@
+package com.mrivanplays.ivancord.api.command;
+
+import com.google.common.base.Splitter;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.function.Predicate;
+import net.md_5.bungee.api.CommandSender;
+import net.md_5.bungee.api.plugin.Command;
+import net.md_5.bungee.api.plugin.Plugin;
+import net.md_5.bungee.api.plugin.TabExecutor;
+
+class Legacy2BrigadierCommandTransformer
+{
+
+    static final Splitter SPACE_SPLITTER = Splitter.on( ' ' );
+
+    static BrigadierCommand transform(Plugin plugin, Command command)
+    {
+        Predicate<CommandSender> requirement = command::hasPermission;
+        com.mojang.brigadier.Command<CommandSender> executes = ( context ) ->
+        {
+            String input = context.getInput();
+            if ( input.indexOf( ' ' ) == -1 )
+            {
+                command.execute( context.getSource(), input.replace( "/", "" ), new String[0] );
+            } else
+            {
+                String[] inputSplit = input.split( " " );
+                String alias = inputSplit[0].replace( "/", "" );
+                String[] args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                command.execute( context.getSource(), alias, args );
+            }
+            // returning single success is of course, a lie
+            // but that's the nature of bungee's command api...
+            return 1;
+        };
+        SuggestionProvider<CommandSender> suggests = ( context, builder ) ->
+        {
+            if ( command instanceof TabExecutor )
+            {
+                String[] inputSplit = SPACE_SPLITTER.splitToList( builder.getInput() ).toArray( new String[0] );
+                String alias = inputSplit[0].replace( "/", "" );
+                String[] args = Arrays.copyOfRange( inputSplit, 1, inputSplit.length );
+                Iterable<String> results = ( (TabExecutor) command ).onTabComplete( context.getSource(), alias, args );
+
+                if ( results != null )
+                {
+                    Iterator<String> iterator = results.iterator();
+                    if ( !iterator.hasNext() )
+                    {
+                        return builder.buildFuture();
+                    }
+                    while ( iterator.hasNext() )
+                    {
+                        builder.suggest( iterator.next() );
+                    }
+                }
+            }
+            return builder.buildFuture();
+        };
+        LiteralCommandNode<CommandSender> base = LiteralArgumentBuilder.<CommandSender>literal( command.getName() )
+            .requires( requirement )
+            .executes( executes )
+            .then( RequiredArgumentBuilder.<CommandSender, String>argument( "args", StringArgumentType.greedyString() )
+                .requires( requirement )
+                .suggests( suggests )
+                .executes( executes )
+            ).build();
+
+        return new BrigadierCommand( plugin, base, command.getAliases() );
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a4f5cf87da15e57db5526fa5fa0eed6cb018e56
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsEvent.java
@@ -0,0 +1,25 @@
+package com.mrivanplays.ivancord.api.event;
+
+import com.mojang.brigadier.suggestion.Suggestions;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.api.connection.Connection;
+import net.md_5.bungee.api.event.TargetedEvent;
+import net.md_5.bungee.api.plugin.Cancellable;
+
+@Getter
+@Setter
+public class BrigadierSuggestionsEvent extends TargetedEvent implements Cancellable
+{
+
+    private boolean cancelled = false;
+    private final String cursor;
+    private Suggestions suggestions;
+
+    public BrigadierSuggestionsEvent(Connection sender, Connection receiver, String cursor, Suggestions suggestions)
+    {
+        super( sender, receiver );
+        this.cursor = cursor;
+        this.suggestions = suggestions;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fc5dc47aacbef26e12902e1f4c668ab4372008f
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/event/BrigadierSuggestionsResponseEvent.java
@@ -0,0 +1,23 @@
+package com.mrivanplays.ivancord.api.event;
+
+import com.mojang.brigadier.suggestion.Suggestions;
+import lombok.Getter;
+import lombok.Setter;
+import net.md_5.bungee.api.connection.Connection;
+import net.md_5.bungee.api.event.TargetedEvent;
+import net.md_5.bungee.api.plugin.Cancellable;
+
+@Getter
+@Setter
+public class BrigadierSuggestionsResponseEvent extends TargetedEvent implements Cancellable
+{
+
+    private boolean cancelled = false;
+    private Suggestions suggestions;
+
+    public BrigadierSuggestionsResponseEvent(Connection sender, Connection receiver, Suggestions suggestions)
+    {
+        super( sender, receiver );
+        this.suggestions = suggestions;
+    }
+}
diff --git a/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java b/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf484b95c9aea0ee9fe15714941d6fc561852459
--- /dev/null
+++ b/api/src/main/java/com/mrivanplays/ivancord/api/util/Constants.java
@@ -0,0 +1,7 @@
+package com.mrivanplays.ivancord.api.util;
+
+public final class Constants
+{
+
+    public static final String[] EMPTY_ARRAY = new String[0];
+}
diff --git a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
index ad096e6575ef1798346f191f41e1e9fec295d954..3c896df72ed58c013a3d9645b21bf11bc9c3b339 100644
--- a/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
+++ b/api/src/main/java/net/md_5/bungee/api/plugin/PluginManager.java
@@ -7,6 +7,12 @@ import com.google.common.eventbus.Subscribe;
 import com.google.common.graph.GraphBuilder;
 import com.google.common.graph.Graphs;
 import com.google.common.graph.MutableGraph;
+// IvanCord start
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mrivanplays.ivancord.api.command.BrigadierCommand;
+import com.mrivanplays.ivancord.api.command.CommandDispatcherProxy;
+// IvanCord end
 import java.io.File;
 import java.io.InputStream;
 import java.lang.reflect.Method;
@@ -64,9 +70,10 @@ public final class PluginManager
     private final Map<String, Plugin> plugins = new LinkedHashMap<>();
     private final MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
     private final LibraryLoader libraryLoader;
-    private final Map<String, Command> commandMap = new HashMap<>();
+    //private final Map<String, Command> commandMap = new HashMap<>(); // IvanCord
+    private final CommandDispatcherProxy commandDispatcher; // IvanCord
     private Map<String, PluginDescription> toLoad = new HashMap<>();
-    private final Multimap<Plugin, Command> commandsByPlugin = ArrayListMultimap.create();
+    //private final Multimap<Plugin, Command> commandsByPlugin = ArrayListMultimap.create(); // IvanCord
     private final Multimap<Plugin, Listener> listenersByPlugin = ArrayListMultimap.create();
 
     @SuppressWarnings("unchecked")
@@ -93,6 +100,7 @@ public final class PluginManager
             proxy.getLogger().warning( "Could not initialize LibraryLoader (missing dependencies?)" );
         }
         this.libraryLoader = libraryLoader;
+        commandDispatcher = new CommandDispatcherProxy( this, proxy ); // IvanCord
     }
 
     /**
@@ -103,14 +111,30 @@ public final class PluginManager
      */
     public void registerCommand(Plugin plugin, Command command)
     {
+        /* // IvanCord start
         commandMap.put( command.getName().toLowerCase( Locale.ROOT ), command );
         for ( String alias : command.getAliases() )
         {
             commandMap.put( alias.toLowerCase( Locale.ROOT ), command );
         }
         commandsByPlugin.put( plugin, command );
+         */
+        commandDispatcher.register( plugin, command );
+        // IvanCord end
+    }
+
+    // IvanCord start - BrigadierCommand API
+    public void registerCommand(BrigadierCommand command)
+    {
+        commandDispatcher.register( command );
     }
 
+    public void unregisterCommand(BrigadierCommand command)
+    {
+        commandDispatcher.unregister( command );
+    }
+    // IvanCord end
+
     /**
      * Unregister a command so it will no longer be executed.
      *
@@ -118,8 +142,12 @@ public final class PluginManager
      */
     public void unregisterCommand(Command command)
     {
+        /* // IvanCord start
         while ( commandMap.values().remove( command ) );
         commandsByPlugin.values().remove( command );
+         */
+        commandDispatcher.unregister( command );
+        // IvanCord end
     }
 
     /**
@@ -129,14 +157,20 @@ public final class PluginManager
      */
     public void unregisterCommands(Plugin plugin)
     {
+        /* // IvanCord start
         for ( Iterator<Command> it = commandsByPlugin.get( plugin ).iterator(); it.hasNext(); )
         {
             Command command = it.next();
             while ( commandMap.values().remove( command ) );
             it.remove();
         }
+         */
+        commandDispatcher.unregisterAll( plugin );
+        // IvanCord end
     }
 
+    // IvanCord start - comment this
+    /*
     private Command getCommandIfEnabled(String commandName, CommandSender sender)
     {
         String commandLower = commandName.toLowerCase( Locale.ROOT );
@@ -149,6 +183,8 @@ public final class PluginManager
 
         return commandMap.get( commandLower );
     }
+     */
+    // IvanCord end
 
     /**
      * Checks if the command is registered and can possibly be executed by the
@@ -160,8 +196,24 @@ public final class PluginManager
      */
     public boolean isExecutableCommand(String commandName, CommandSender sender)
     {
-        return getCommandIfEnabled( commandName, sender ) != null;
+        return commandDispatcher.isExecutable( commandName, sender ); // IvanCord
+    }
+
+    // IvanCord start
+
+    /**
+     * Retrieves command in a legacy form by the name/alias specified.
+     *
+     * @param name command name/alias
+     * @return command or null
+     * @deprecated internal use only in order to support waterfall's ProxyDefineCommandsEvent
+     */
+    @Deprecated
+    public Command getCommand(String name)
+    {
+        return commandDispatcher.getCommand( name.toLowerCase() );
     }
+    // IvanCord end
 
     public boolean dispatchCommand(CommandSender sender, String commandLine)
     {
@@ -181,6 +233,30 @@ public final class PluginManager
      */
     public boolean dispatchCommand(CommandSender sender, String commandLine, List<String> tabResults)
     {
+        // IvanCord start - replace this whoooooooooooooooooooole stuff
+        if ( tabResults == null )
+        {
+            int result = commandDispatcher.dispatch( sender, commandLine );
+            if ( result == 1 )
+            {
+                if ( proxy.getConfig().isLogCommands() )
+                {
+                    proxy.getLogger().log( Level.INFO, "{0} executed command /{1}", new Object[]
+                    {
+                        sender.getName(), commandLine
+                    } );
+                }
+                return true;
+            } else
+            {
+                return result == 2;
+            }
+        } else
+        {
+            tabResults.addAll( commandDispatcher.complete( sender, commandLine, true ) );
+            return true;
+        }
+        /*
         String[] split = commandLine.split( " ", -1 );
         // Check for chat that only contains " "
         if ( split.length == 0 || split[0].isEmpty() )
@@ -238,6 +314,7 @@ public final class PluginManager
         // Waterfall end
             }
         return true;
+         */ // IvanCord end
     }
 
     // Waterfall start - Add method to tab-complete command names
@@ -253,6 +330,9 @@ public final class PluginManager
      * @return The tab-complete suggestions
      */
     public List<String> tabCompleteCommand(CommandSender sender, String commandLine) {
+        // IvanCord start - replace
+        return commandDispatcher.completeWithNames( sender, commandLine );
+        /*
         List<String> suggestions = new java.util.ArrayList<>();
 
         if (commandLine.indexOf(' ') == -1) {
@@ -272,9 +352,17 @@ public final class PluginManager
         }
 
         return suggestions;
+         */ // IvanCord end
     }
     // Waterfall end
 
+    // IvanCord start - additional completion stuff
+    public java.util.concurrent.CompletableFuture<Suggestions> getBrigadierCompletions(CommandSender sender, String commandLine)
+    {
+        return commandDispatcher.complete( sender, commandLine );
+    }
+    // IvanCord end
+
     /**
      * Returns the {@link Plugin} objects corresponding to all loaded plugins.
      *
@@ -546,7 +634,8 @@ public final class PluginManager
      */
     public Collection<Map.Entry<String, Command>> getCommands()
     {
-        return Collections.unmodifiableCollection( commandMap.entrySet() );
+        //return Collections.unmodifiableCollection( commandMap.entrySet() ); // IvanCord
+        return commandDispatcher.getCommands(); // IvanCord
     }
 
     boolean isTransitiveDepend(PluginDescription plugin, PluginDescription depend)
@@ -640,4 +729,17 @@ public final class PluginManager
         return plugins.containsKey( plugin.getDescription().getName() );
     }
     // IvanCord end
+
+    // IvanCord start - commands as brigadier commands :)
+
+    /**
+     * Gets all registered commands as brigadier commands.
+     *
+     * @return unmodifiable collection of brigadier commands
+     */
+    public Collection<CommandNode<CommandSender>> getCommandsAsBrigadier()
+    {
+        return commandDispatcher.getBrigadierCommands();
+    }
+    // IvanCord end
 }
diff --git a/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3a8c5e22860ab314553019f267be2bc5e3a16fc
--- /dev/null
+++ b/protocol/src/main/java/com/mrivanplays/ivancord/api/command/message/BungeeMessage.java
@@ -0,0 +1,134 @@
+package com.mrivanplays.ivancord.api.command.message;
+
+import com.google.gson.JsonSyntaxException;
+import com.mojang.brigadier.Message;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.md_5.bungee.api.ChatColor;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.chat.TranslatableComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
+/**
+ * Represents a BungeeCord implementation of the Brigadier's {@link Message} interface.
+ * With it, you are able to send custom messages to the command senders, using
+ * {@link com.mojang.brigadier.suggestion.SuggestionsBuilder#suggest(String, Message)}
+ */
+public final class BungeeMessage implements Message
+{
+
+    /**
+     * Converts the provided {@link CommandSyntaxException} into a BungeeCord style message.
+     *
+     * @param exception the exception provided
+     * @return a message that could be directly sent to a CommandExecutor
+     */
+    public static BaseComponent convertSyntaxException(CommandSyntaxException exception)
+    {
+        Message rawMessage = exception.getRawMessage();
+        TextComponent text;
+        if ( rawMessage instanceof BungeeMessage )
+        {
+            BungeeMessage bungeeMessage = (BungeeMessage) rawMessage;
+            text = new TextComponent( bungeeMessage.getMessage() );
+        } else
+        {
+            try
+            {
+                BaseComponent[] parsedJson = ComponentSerializer.parse( rawMessage.getString() );
+                text = new TextComponent( parsedJson );
+            } catch ( JsonSyntaxException e )
+            {
+                text = new TextComponent( rawMessage.getString() );
+                text.setColor( ChatColor.RED );
+            }
+        }
+
+        TextComponent context = convertContextOf( exception );
+
+        if ( context != null )
+        {
+            TranslatableComponent ret =
+                new TranslatableComponent( "command.context.parse_error", text, exception.getCursor(), context );
+            ret.setColor( ChatColor.RED );
+            return ret;
+        }
+
+        return text;
+    }
+
+    /**
+     * Converts {@link CommandSyntaxException#getContext()} to a component.
+     *
+     * @param exception the exception provided
+     * @return converted context, or null
+     */
+    public static TextComponent convertContextOf(CommandSyntaxException exception)
+    {
+        String input = exception.getInput();
+        int startingCursor = exception.getCursor();
+        if ( input == null || startingCursor < 0 )
+        {
+            return null;
+        }
+
+        TextComponent component = new TextComponent();
+        int cursor = Math.min( input.length(), startingCursor );
+        if ( cursor > CommandSyntaxException.CONTEXT_AMOUNT )
+        {
+            component.addExtra( "..." );
+        }
+        component.addExtra( input.substring( Math.max( 0, cursor - CommandSyntaxException.CONTEXT_AMOUNT ), cursor ) );
+        component.setColor( ChatColor.GRAY );
+
+        TranslatableComponent hereParam = new TranslatableComponent( "command.context.here" );
+        hereParam.setColor( ChatColor.RED );
+        component.addExtra( hereParam );
+
+        return component;
+    }
+
+    private final String legacyText;
+    private final BaseComponent[] message;
+
+    /**
+     * Creates a new {@link BungeeMessage}
+     *
+     * @param text components
+     */
+    public BungeeMessage(BaseComponent... text)
+    {
+        this.message = text;
+        if ( this.message != null )
+        {
+            this.legacyText = BaseComponent.toLegacyText( text );
+        } else
+        {
+            this.legacyText = null;
+        }
+    }
+
+    /**
+     * Returns the message provided.
+     *
+     * @return message
+     */
+    public BaseComponent[] getMessage()
+    {
+        return message;
+    }
+
+    @Override
+    public String getString()
+    {
+        return this.legacyText;
+    }
+
+    @Override
+    public String toString()
+    {
+        return "BungeeMessage{" +
+            "message=" + this.legacyText +
+            '}';
+    }
+}
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
index 26edbca85b40fd0be24a5745f0361157131f45f1..72350f514212890d97713032c982f7eb75ba4224 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Commands.java
@@ -4,6 +4,7 @@ import com.google.common.base.Preconditions;
 import com.mojang.brigadier.Command;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.BoolArgumentType; // IvanCord
 import com.mojang.brigadier.arguments.DoubleArgumentType;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
@@ -323,19 +324,28 @@ public class Commands extends DefinedPacket
             {
             }
         };
-        private static final ArgumentSerializer<Boolean> BOOLEAN = new ArgumentSerializer<Boolean>()
+        private static final ProperArgumentSerializer<BoolArgumentType> BOOLEAN = new ProperArgumentSerializer<BoolArgumentType>() // IvanCord
         {
             @Override
-            protected Boolean read(ByteBuf buf)
+            protected BoolArgumentType read(ByteBuf buf) // IvanCord
             {
-                return buf.readBoolean();
+                return BoolArgumentType.bool(); // IvanCord
             }
 
             @Override
-            protected void write(ByteBuf buf, Boolean t)
+            protected void write(ByteBuf buf, BoolArgumentType t) // IvanCord
             {
-                buf.writeBoolean( t );
+                // IvanCord - NOOP
+                //buf.writeBoolean( t );
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:bool";
+            }
+            // IvanCord end
         };
         private static final ArgumentSerializer<Byte> BYTE = new ArgumentSerializer<Byte>()
         {
@@ -351,7 +361,7 @@ public class Commands extends DefinedPacket
                 buf.writeByte( t );
             }
         };
-        private static final ArgumentSerializer<FloatArgumentType> FLOAT = new ArgumentSerializer<FloatArgumentType>()
+        private static final ProperArgumentSerializer<FloatArgumentType> FLOAT = new ProperArgumentSerializer<FloatArgumentType>() // IvanCord
         {
             @Override
             protected FloatArgumentType read(ByteBuf buf)
@@ -379,8 +389,16 @@ public class Commands extends DefinedPacket
                     buf.writeFloat( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:float";
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<DoubleArgumentType> DOUBLE = new ArgumentSerializer<DoubleArgumentType>()
+        private static final ProperArgumentSerializer<DoubleArgumentType> DOUBLE = new ProperArgumentSerializer<DoubleArgumentType>() // IvanCord
         {
             @Override
             protected DoubleArgumentType read(ByteBuf buf)
@@ -408,8 +426,16 @@ public class Commands extends DefinedPacket
                     buf.writeDouble( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:double";
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<IntegerArgumentType> INTEGER = new ArgumentSerializer<IntegerArgumentType>()
+        private static final ProperArgumentSerializer<IntegerArgumentType> INTEGER = new ProperArgumentSerializer<IntegerArgumentType>() // IvanCord
         {
             @Override
             protected IntegerArgumentType read(ByteBuf buf)
@@ -437,8 +463,16 @@ public class Commands extends DefinedPacket
                     buf.writeInt( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:integer";
+            }
+            // IvanCord end
         };
-        private static final ArgumentSerializer<LongArgumentType> LONG = new ArgumentSerializer<LongArgumentType>()
+        private static final ProperArgumentSerializer<LongArgumentType> LONG = new ProperArgumentSerializer<LongArgumentType>() // IvanCord
         {
             @Override
             protected LongArgumentType read(ByteBuf buf)
@@ -466,6 +500,14 @@ public class Commands extends DefinedPacket
                     buf.writeLong( t.getMaximum() );
                 }
             }
+
+            // IvanCord start
+            @Override
+            protected String getKey()
+            {
+                return "brigadier:long";
+            }
+            // IvanCord end
         };
         private static final ProperArgumentSerializer<StringArgumentType> STRING = new ProperArgumentSerializer<StringArgumentType>()
         {
@@ -502,14 +544,20 @@ public class Commands extends DefinedPacket
         static
         {
             PROVIDERS.put( "brigadier:bool", VOID );
+            PROPER_PROVIDERS.put( BoolArgumentType.class, BOOLEAN ); // IvanCord
             PROVIDERS.put( "brigadier:float", FLOAT );
+            PROPER_PROVIDERS.put( FloatArgumentType.class, FLOAT ); // IvanCord
             PROVIDERS.put( "brigadier:double", DOUBLE );
+            PROPER_PROVIDERS.put( DoubleArgumentType.class, DOUBLE ); // IvanCord
             PROVIDERS.put( "brigadier:integer", INTEGER );
+            PROPER_PROVIDERS.put( IntegerArgumentType.class, INTEGER ); // IvanCord
             PROVIDERS.put( "brigadier:long", LONG );
+            PROPER_PROVIDERS.put( LongArgumentType.class, LONG ); // IvanCord
 
             PROVIDERS.put( "brigadier:string", STRING );
             PROPER_PROVIDERS.put( StringArgumentType.class, STRING );
 
+            // IvanCord TODO: create serializers for the useful arguments down there
             PROVIDERS.put( "minecraft:entity", BYTE );
             PROVIDERS.put( "minecraft:game_profile", VOID );
             PROVIDERS.put( "minecraft:block_pos", VOID );
@@ -614,15 +662,28 @@ public class Commands extends DefinedPacket
     {
 
         public static final SuggestionProvider ASK_SERVER = new DummyProvider( "minecraft:ask_server" );
+        // IvanCord start
+        public static final SuggestionProvider ALL_RECIPES = new DummyProvider( "minecraft:all_recipes" );
+        public static final SuggestionProvider AVAILABLE_SOUNDS = new DummyProvider( "minecraft:available_sounds" );
+        public static final SuggestionProvider AVAILABLE_BIOMES = new DummyProvider( "minecraft:available_biomes" );
+        public static final SuggestionProvider SUMMONABLE_ENTITIES = new DummyProvider( "minecraft:summonable_entities" );
+        // IvanCord end
         private static final Map<String, SuggestionProvider<DummyProvider>> PROVIDERS = new HashMap<>();
 
         static
         {
             PROVIDERS.put( "minecraft:ask_server", ASK_SERVER );
+            // IvanCord start - no dummies - expose SuggestionRegistry
+            PROVIDERS.put( "minecraft:all_recipes", ALL_RECIPES );
+            PROVIDERS.put( "minecraft:available_sounds", AVAILABLE_SOUNDS );
+            PROVIDERS.put( "minecraft:available_biomes", AVAILABLE_BIOMES );
+            PROVIDERS.put( "minecraft:summonable_entities", SUMMONABLE_ENTITIES );
+            /*
             registerDummy( "minecraft:all_recipes" );
             registerDummy( "minecraft:available_sounds" );
             registerDummy( "minecraft:available_biomes" );
             registerDummy( "minecraft:summonable_entities" );
+             */ // IvanCord end
         }
 
         private static void registerDummy(String name)
@@ -640,9 +701,20 @@ public class Commands extends DefinedPacket
 
         private static String getKey(SuggestionProvider<DummyProvider> provider)
         {
+            // IvanCord start - change
+            if ( provider instanceof DummyProvider )
+            {
+                return ( (DummyProvider) provider ).key;
+            } else
+            {
+                // in case mojang changes it
+                return ( (DummyProvider) ASK_SERVER ).key;
+            }
+            /*
             Preconditions.checkArgument( provider instanceof DummyProvider, "Non dummy provider " + provider );
 
             return ( (DummyProvider) provider ).key;
+             */ // IvanCord end
         }
 
         @Data
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
index ca7c6342bb678187432adb93aca7b20fbe71a200..3109f17ea0c38de32e31acaf9ae24b4e2eaca625 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/TabCompleteResponse.java
@@ -53,7 +53,39 @@ public class TabCompleteResponse extends DefinedPacket
                 String match = readString( buf );
                 String tooltip = buf.readBoolean() ? readString( buf ) : null;
 
+                // IvanCord start - replace
+                /*
                 matches.add( new Suggestion( range, match, new LiteralMessage( tooltip ) ) );
+                 */
+                if ( tooltip != null )
+                {
+                    try
+                    {
+                        net.md_5.bungee.api.chat.BaseComponent[] message =
+                            net.md_5.bungee.chat.ComponentSerializer.parse( tooltip );
+                        matches.add(
+                            new Suggestion(
+                                range, match,
+                                new com.mrivanplays.ivancord.api.command.message.BungeeMessage( message )
+                            )
+                        );
+                    } catch ( com.google.gson.JsonSyntaxException e )
+                    {
+                        // convert to json
+                        matches.add(
+                            new Suggestion(
+                                range, match,
+                                new com.mrivanplays.ivancord.api.command.message.BungeeMessage(
+                                    net.md_5.bungee.api.chat.TextComponent.fromLegacyText( tooltip )
+                                )
+                            )
+                        );
+                    }
+                } else
+                {
+                    matches.add( new Suggestion( range, match ) );
+                }
+                // IvanCord end
             }
 
             suggestions = new Suggestions( range, matches );
@@ -78,11 +110,53 @@ public class TabCompleteResponse extends DefinedPacket
             for ( Suggestion suggestion : suggestions.getList() )
             {
                 writeString( suggestion.getText(), buf );
+                // IvanCord start - rewrite this
+                /*
                 buf.writeBoolean( suggestion.getTooltip() != null && suggestion.getTooltip().getString() != null );
                 if ( suggestion.getTooltip() != null && suggestion.getTooltip().getString() != null )
                 {
                     writeString( suggestion.getTooltip().getString(), buf );
                 }
+                 */
+                if ( suggestion.getTooltip() != null )
+                {
+                    com.mojang.brigadier.Message tooltip = suggestion.getTooltip();
+                    if ( tooltip instanceof com.mrivanplays.ivancord.api.command.message.BungeeMessage )
+                    {
+                        com.mrivanplays.ivancord.api.command.message.BungeeMessage
+                            bungee = (com.mrivanplays.ivancord.api.command.message.BungeeMessage) tooltip;
+                        buf.writeBoolean( bungee.getMessage() != null );
+                        if ( bungee.getMessage() != null )
+                        {
+                            writeString( net.md_5.bungee.chat.ComponentSerializer.toString( bungee.getMessage() ), buf );
+                        }
+                    } else
+                    {
+                        buf.writeBoolean( tooltip.getString() != null );
+                        if ( tooltip.getString() != null )
+                        {
+                            // make sure this is json - otherwise we'll have some trouble
+                            try
+                            {
+                                net.md_5.bungee.chat.ComponentSerializer.parse( tooltip.getString() );
+                                writeString( tooltip.getString(), buf );
+                            } catch ( com.google.gson.JsonSyntaxException e )
+                            {
+                                // not json, have to use text components
+                                writeString(
+                                    net.md_5.bungee.chat.ComponentSerializer.toString(
+                                        new net.md_5.bungee.api.chat.TextComponent( tooltip.getString() )
+                                    ),
+                                    buf
+                                );
+                            }
+                        }
+                    }
+                } else
+                {
+                    buf.writeBoolean( false );
+                }
+                // IvanCord end
             }
         }
 
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
index adcd895b423df476ad732c9c64e016f1f6baff4e..87122de04f0bf10a2382776cb575beeec6496a08 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/DownstreamBridge.java
@@ -6,13 +6,16 @@ import com.google.common.collect.Lists;
 import com.google.common.io.ByteArrayDataOutput;
 import com.google.common.io.ByteStreams;
 import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.ArgumentBuilder; // IvanCord
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
 import com.mojang.brigadier.context.StringRange;
 import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.tree.CommandNode; // IvanCord
 import com.mojang.brigadier.tree.LiteralCommandNode;
 
+import com.mojang.brigadier.tree.RootCommandNode; // IvanCord
 import io.github.waterfallmc.waterfall.event.ProxyDefineCommandsEvent; // Waterfall
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
@@ -30,6 +33,7 @@ import net.md_5.bungee.ServerConnection;
 import net.md_5.bungee.ServerConnection.KeepAliveData;
 import net.md_5.bungee.UserConnection;
 import net.md_5.bungee.Util;
+import net.md_5.bungee.api.CommandSender; // IvanCord
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.api.chat.ComponentBuilder; // IvanCord
 import net.md_5.bungee.api.chat.BaseComponent;
@@ -634,6 +638,65 @@ public class DownstreamBridge extends PacketHandler
     @Override
     public void handle(TabCompleteResponse tabCompleteResponse) throws Exception
     {
+        // IvanCord start - ditch whole impl
+        // rewrite
+        List<String> commands = tabCompleteResponse.getCommands();
+        if ( commands != null )
+        {
+            // legacy
+            TabCompleteResponseEvent tabCompleteEvent = new TabCompleteResponseEvent( server, con, new ArrayList<>( commands ) );
+            if ( !bungee.getPluginManager().callEvent( tabCompleteEvent ).isCancelled() && !commands.equals( tabCompleteEvent.getSuggestions() ) )
+            {
+                tabCompleteResponse.setCommands( tabCompleteEvent.getSuggestions() );
+                con.unsafe().sendPacket( tabCompleteResponse );
+            }
+        } else
+        {
+            // brigadier
+            Suggestions initial = tabCompleteResponse.getSuggestions();
+            com.mrivanplays.ivancord.api.event.BrigadierSuggestionsResponseEvent brigadierEvent =
+                new com.mrivanplays.ivancord.api.event.BrigadierSuggestionsResponseEvent( server, con, initial );
+            if ( !bungee.getPluginManager().callEvent( brigadierEvent ).isCancelled() )
+            {
+                Suggestions fromEvent = brigadierEvent.getSuggestions();
+
+                // call bungee's event so we don't make them plugins bork and devlopers crying
+                commands = new ArrayList<>();
+                for ( Suggestion suggestion : fromEvent.getList() )
+                {
+                    commands.add( suggestion.getText() );
+                }
+                TabCompleteResponseEvent tabCompleteEvent = new TabCompleteResponseEvent( server, con, commands );
+                if ( !bungee.getPluginManager().callEvent( tabCompleteEvent ).isCancelled() )
+                {
+                    List<String> updated = tabCompleteEvent.getSuggestions();
+                    if ( commands.equals( updated ) )
+                    {
+                        // in case the first event changed sth
+                        tabCompleteResponse.setSuggestions( fromEvent );
+                        con.unsafe().sendPacket( tabCompleteResponse );
+                        throw CancelSendSignal.INSTANCE;
+                    }
+
+                    List<Suggestion> suggestions = new ArrayList<>();
+                    for ( Suggestion suggestion : fromEvent.getList() )
+                    {
+                        String value = suggestion.getText();
+                        for ( String update : updated )
+                        {
+                            if ( update.toLowerCase().equalsIgnoreCase( value.toLowerCase() ) )
+                            {
+                                suggestions.add( suggestion );
+                            }
+                        }
+                    }
+
+                    tabCompleteResponse.setSuggestions( new Suggestions( fromEvent.getRange(), suggestions ) );
+                    con.unsafe().sendPacket( tabCompleteResponse );
+                }
+            }
+        }
+        /*
         List<String> commands = tabCompleteResponse.getCommands();
         if ( commands == null )
         {
@@ -674,6 +737,7 @@ public class DownstreamBridge extends PacketHandler
 
             con.unsafe().sendPacket( tabCompleteResponse );
         }
+         */ // IvanCord end
 
         throw CancelSendSignal.INSTANCE;
     }
@@ -736,6 +800,8 @@ public class DownstreamBridge extends PacketHandler
     {
         boolean modified = false;
 
+        // IvanCord start - replace impl completely
+        /*
         // Waterfall start
         Map<String, Command> commandMap = new HashMap<>();
         for ( Map.Entry<String, Command> commandEntry : bungee.getPluginManager().getCommands() ) {
@@ -765,6 +831,43 @@ public class DownstreamBridge extends PacketHandler
                 modified = true;
             }
         }
+         */
+        // since we don't want to expose the CommandDispatcherProxy in PluginManager thats how we should construct
+        // the root node.
+        RootCommandNode<CommandSender> rootCopy = new RootCommandNode<>();
+        for ( CommandNode<CommandSender> node : bungee.getPluginManager().getCommandsAsBrigadier() )
+        {
+            rootCopy.addChild( node );
+        }
+        RootCommandNode<CommandSender> filtered =
+            (RootCommandNode<CommandSender>) filterCommandNode( rootCopy, new java.util.IdentityHashMap<>() );
+        java.util.Collection<CommandNode<CommandSender>> nodes = filtered.getChildren();
+        if ( nodes.isEmpty() )
+        {
+            return;
+        }
+        Map<String, Command> commandMap = new HashMap<>();
+        for ( CommandNode<CommandSender> node : nodes )
+        {
+            Command legacy = bungee.getPluginManager().getCommand( node.getName() );
+            if ( legacy != null )
+            {
+                commandMap.put( node.getName(), legacy );
+            }
+        }
+        ProxyDefineCommandsEvent defineCommandsEvent = new ProxyDefineCommandsEvent( server, con, commandMap );
+        bungee.getPluginManager().callEvent( defineCommandsEvent );
+        Map<String, Command> updatedMap = defineCommandsEvent.getCommands();
+        for ( String name : updatedMap.keySet() )
+        {
+            CommandNode<CommandSender> node = filtered.getChild( name );
+            if ( node != null )
+            {
+                commands.getRoot().addChild( node );
+                modified = true;
+            }
+        }
+        // IvanCord end
 
         if ( modified )
         {
@@ -773,6 +876,68 @@ public class DownstreamBridge extends PacketHandler
         }
     }
 
+    // IvanCord start
+    private CommandNode<CommandSender> filterCommandNode(
+        CommandNode<CommandSender> source,
+        Map<CommandNode<CommandSender>, CommandNode<CommandSender>> commandNodeMapping
+    )
+    {
+        CommandNode<CommandSender> dest;
+        if ( source instanceof RootCommandNode )
+        {
+            dest = new RootCommandNode<>();
+        } else
+        {
+            if ( bungee.getDisabledCommands().contains( source.getName() ) )
+            {
+                commandNodeMapping.put( source, null );
+                return null;
+            }
+            if ( source.getRequirement() != null )
+            {
+                try
+                {
+                    if ( !source.getRequirement().test( con ) )
+                    {
+                        commandNodeMapping.put( source, null );
+                        return null;
+                    }
+                } catch ( Throwable t )
+                {
+                    bungee.getLogger().log( java.util.logging.Level.SEVERE, "Requirement test for command node " + source + " encountered an exception", t );
+                }
+            }
+
+            ArgumentBuilder<CommandSender, ?> destChildBuilder = source.createBuilder();
+            destChildBuilder.requires( sender -> true );
+            if ( destChildBuilder.getRedirect() != null )
+            {
+                if ( commandNodeMapping.containsKey( destChildBuilder.getRedirect() ) )
+                {
+                    destChildBuilder.redirect( commandNodeMapping.get( destChildBuilder.getRedirect() ) );
+                } else
+                {
+                    destChildBuilder.redirect( filterCommandNode( destChildBuilder.getRedirect(), commandNodeMapping ) );
+                }
+            }
+            dest = destChildBuilder.build();
+        }
+
+        for ( CommandNode<CommandSender> sourceChild : source.getChildren() )
+        {
+            CommandNode<CommandSender> destChild = filterCommandNode( sourceChild, commandNodeMapping );
+            if ( destChild == null )
+            {
+                continue;
+            }
+            dest.addChild( destChild );
+        }
+        commandNodeMapping.put( source, dest );
+
+        return dest;
+    }
+    // IvanCord end
+
     // IvanCord start
     @Override
     public void handle(PlayerPosition pac)
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 1d1c89b58beca05802d970f997484f82a1de2331..4603408e1af16a2d8e71b08dbc294feb7cc8302a 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -193,6 +193,87 @@ public class UpstreamBridge extends PacketHandler
         }
 
         // Waterfall end - tab limiter
+        // IvanCord start - ditch whole impl
+        // reimplement this entirely
+        if ( con.getPendingConnection().getVersion() < ProtocolConstants.MINECRAFT_1_13 )
+        {
+            List<String> suggestions = new ArrayList<>();
+            if ( tabComplete.getCursor().startsWith( "/" ) )
+            {
+                bungee.getPluginManager().dispatchCommand( con, tabComplete.getCursor().substring( 1 ), suggestions );
+            }
+
+            TabCompleteEvent event = bungee.getPluginManager().callEvent( new TabCompleteEvent( con, con.getServer(), tabComplete.getCursor(), suggestions ) );
+            if ( event.isCancelled() )
+            {
+                throw CancelSendSignal.INSTANCE;
+            }
+
+            List<String> results = event.getSuggestions();
+            if ( !results.isEmpty() )
+            {
+                con.unsafe().sendPacket( new TabCompleteResponse( results ) );
+                throw CancelSendSignal.INSTANCE;
+            }
+        } else
+        {
+            // alright, my turn
+            Suggestions fromDispatcher = Suggestions.empty().join();
+            if ( tabComplete.getCursor().startsWith( "/" ) )
+            {
+                fromDispatcher = bungee.getPluginManager().getBrigadierCompletions( con, tabComplete.getCursor().substring( 1 ) ).join();
+            }
+            int start = tabComplete.getCursor().lastIndexOf( ' ' ) + 1;
+            int end = tabComplete.getCursor().length();
+            StringRange range = StringRange.between( start, end );
+            Suggestions suggestions = new Suggestions( range, fromDispatcher.getList() );
+
+            com.mrivanplays.ivancord.api.event.BrigadierSuggestionsEvent brigadierEvent =
+                bungee.getPluginManager().callEvent( new com.mrivanplays.ivancord.api.event.BrigadierSuggestionsEvent( con, con.getServer(), tabComplete.getCursor(), suggestions ) );
+            if ( brigadierEvent.isCancelled() )
+            {
+                throw CancelSendSignal.INSTANCE;
+            }
+            Suggestions suggestionsResult = brigadierEvent.getSuggestions();
+            if ( !suggestionsResult.isEmpty() )
+            {
+                // call bungee's event so we don't make them plugins bork and devlopers crying
+                List<String> suggestionsList = new ArrayList<>();
+                for ( Suggestion suggestion : suggestionsResult.getList() )
+                {
+                    suggestionsList.add( suggestion.getText() );
+                }
+                TabCompleteEvent bungeeEvent =
+                    bungee.getPluginManager().callEvent( new TabCompleteEvent( con, con.getServer(), tabComplete.getCursor(), suggestionsList ) );
+                if ( bungeeEvent.isCancelled() )
+                {
+                    throw CancelSendSignal.INSTANCE;
+                }
+
+                List<String> results = bungeeEvent.getSuggestions();
+                if ( !results.isEmpty() )
+                {
+                    List<Suggestion> suggestionList = new ArrayList<>();
+                    for ( Suggestion suggestion : suggestionsResult.getList() )
+                    {
+                        String suggestionText = suggestion.getText();
+                        for ( String result : results )
+                        {
+                            if ( suggestionText.toLowerCase().equalsIgnoreCase( result.toLowerCase() ) )
+                            {
+                                suggestionList.add( suggestion );
+                            }
+                        }
+                    }
+                    if ( !suggestionList.isEmpty() )
+                    {
+                        con.unsafe().sendPacket( new TabCompleteResponse( tabComplete.getTransactionId(), new Suggestions( range, suggestionList ) ) );
+                        throw CancelSendSignal.INSTANCE;
+                    }
+                }
+            }
+        }
+        /*
         List<String> suggestions = new ArrayList<>();
 
         if ( tabComplete.getCursor().startsWith( "/" ) )
@@ -232,6 +313,7 @@ public class UpstreamBridge extends PacketHandler
             }
             throw CancelSendSignal.INSTANCE;
         }
+         */ // IvanCord end
     }
 
     @Override
diff --git a/proxy/src/main/resources/messages.properties b/proxy/src/main/resources/messages.properties
index 55493ee39edcbd362ae43d7c748cadf80c98e7ab..f14b215e742b428cad5d7a087712244a7bbc0c74 100644
--- a/proxy/src/main/resources/messages.properties
+++ b/proxy/src/main/resources/messages.properties
@@ -40,3 +40,5 @@ command_perms_permission=\u00a79- {0}
 command_ip=\u00a79IP of {0} is {1}
 kick_to_lobby=You were kicked from server {0} with reason {1} . The fallback sent you to {2}
 command_plugins_message=Plugins ({0}): {1}
+internal_error_executing=\u00a7cAn internal error occurred whilst executing this command, please check the console log for details.
+internal_error_completing=\u00a7cAn internal error occurred whilst tab completing this command, please check the console log for details.
