From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <pekov.ivan@abv.bg>
Date: Fri, 14 Jun 2019 16:38:20 +0300
Subject: [PATCH] Add support for json configuration files

This patch adds support for json
configuration files using gson

diff --git a/config/pom.xml b/config/pom.xml
index 77e2bae26cea98e9284266c7e699fc2e7f547117..e7c975e274bf8f35d1927a9396d8345b78a21a50 100644
--- a/config/pom.xml
+++ b/config/pom.xml
@@ -24,5 +24,12 @@
             <version>1.25</version>
             <scope>compile</scope>
         </dependency>
+        <!-- IvanCord - add gson -->
+        <dependency>
+            <groupId>com.google.code.gson</groupId>
+            <artifactId>gson</artifactId>
+            <version>2.8.0</version>
+            <scope>provided</scope>
+        </dependency>
     </dependencies>
 </project>
diff --git a/config/src/main/java/com/mrivanplays/ivancord/config/MapSerializer.java b/config/src/main/java/com/mrivanplays/ivancord/config/MapSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c68aab1a925d42a7f89f1490ca930d87ae5ffaa
--- /dev/null
+++ b/config/src/main/java/com/mrivanplays/ivancord/config/MapSerializer.java
@@ -0,0 +1,112 @@
+package com.mrivanplays.ivancord.config;
+
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonDeserializationContext;
+import com.google.gson.JsonDeserializer;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.google.gson.reflect.TypeToken;
+
+public class MapSerializer implements JsonSerializer<Map<String, Object>>, JsonDeserializer<Map<String, Object>>
+{
+
+    private Type mapType;
+
+    public MapSerializer()
+    {
+        this.mapType = new TypeToken<Map<String, Object>>(){}.getType();
+    }
+
+    @Override
+    public Map<String, Object> deserialize(JsonElement element, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
+    {
+        Map<String, Object> map = new LinkedHashMap<>();
+        JsonObject object = element.getAsJsonObject();
+        List<Map.Entry<String, JsonElement>> primitives = object.entrySet()
+                .parallelStream()
+                .filter( entry -> entry.getValue().isJsonPrimitive() )
+                .collect( Collectors.toList() );
+        for ( Map.Entry<String, JsonElement> entry : primitives )
+        {
+            String key = entry.getKey();
+            JsonPrimitive value = entry.getValue().getAsJsonPrimitive();
+            if ( value.isBoolean() )
+            {
+                map.put( key, value.getAsBoolean() );
+            }
+            if ( value.isNumber() )
+            {
+                map.put( key, value.getAsNumber() );
+            }
+            if ( value.isString() )
+            {
+                map.put( key, value.getAsString() );
+            }
+        }
+        List<Map.Entry<String, JsonElement>> arrays = object.entrySet()
+                .parallelStream()
+                .filter( entry -> entry.getValue().isJsonArray() )
+                .collect( Collectors.toList() );
+        for ( Map.Entry<String, JsonElement> entry : arrays )
+        {
+            String key = entry.getKey();
+            JsonArray array = entry.getValue().getAsJsonArray();
+            map.put( key, ObjectToListSerializer.deserialize( array ) );
+        }
+        List<Map.Entry<String, JsonElement>> objects = object.entrySet()
+                .parallelStream()
+                .filter( entry -> entry.getValue().isJsonObject() )
+                .collect( Collectors.toList() );
+        for ( Map.Entry<String, JsonElement> entry : objects )
+        {
+            String key = entry.getKey();
+            JsonObject obj = entry.getValue().getAsJsonObject();
+            map.put( key, context.deserialize( obj, mapType ) );
+        }
+        return map;
+    }
+
+    @Override
+    public JsonElement serialize(Map<String, Object> src, Type typeOfSrc, JsonSerializationContext context)
+    {
+        JsonObject object = new JsonObject();
+        for ( Map.Entry<String, Object> entry : src.entrySet() )
+        {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            if ( value instanceof Boolean )
+            {
+                object.addProperty( key, (Boolean) value );
+            }
+            if ( value instanceof String )
+            {
+                object.addProperty( key, String.valueOf( value ) );
+            }
+            if ( value instanceof Number )
+            {
+                object.addProperty( key, (Number) value );
+            }
+            if ( value instanceof Map )
+            {
+                Map map = (Map) value;
+                object.add( key, context.serialize( map, JsonObject.class ) );
+            }
+            if ( value instanceof List<?> )
+            {
+                List<?> list = (List<?>) value;
+                object.add( key, ObjectToListSerializer.serialize( list ) );
+            }
+        }
+        return object;
+    }
+}
\ No newline at end of file
diff --git a/config/src/main/java/com/mrivanplays/ivancord/config/ObjectToListSerializer.java b/config/src/main/java/com/mrivanplays/ivancord/config/ObjectToListSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..522dd70ca7a8e303f4368226edce2320ce9e8b98
--- /dev/null
+++ b/config/src/main/java/com/mrivanplays/ivancord/config/ObjectToListSerializer.java
@@ -0,0 +1,56 @@
+package com.mrivanplays.ivancord.config;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonPrimitive;
+
+public class ObjectToListSerializer
+{
+
+    public static JsonArray serialize(List<?> list)
+    {
+        JsonArray array = new JsonArray();
+        for ( Object o : list )
+        {
+            if ( o instanceof String )
+            {
+                array.add( (String) o );
+            }
+            if ( o instanceof Boolean )
+            {
+                array.add( (Boolean) o );
+            }
+            if ( o instanceof Number )
+            {
+                array.add( (Number) o );
+            }
+        }
+        return array;
+    }
+
+    public static List<?> deserialize(JsonArray array)
+    {
+        List list = new ArrayList<>();
+        for ( JsonElement element : array )
+        {
+            JsonPrimitive primitive = element.getAsJsonPrimitive();
+            if ( primitive.isString() )
+            {
+                list.add( primitive.getAsString() );
+            }
+            if ( primitive.isBoolean() )
+            {
+                list.add( primitive.getAsBoolean() );
+            }
+            if ( primitive.isNumber() )
+            {
+                list.add( primitive.getAsNumber() );
+            }
+        }
+        return list;
+    }
+
+}
diff --git a/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java b/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
index 5b6ff2ebebedc41622314267146b38e296ace0c2..8f7119b19ee3e5fe17964466d446c2da10777da6 100644
--- a/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
+++ b/config/src/main/java/net/md_5/bungee/config/ConfigurationProvider.java
@@ -12,14 +12,28 @@ public abstract class ConfigurationProvider
 {
 
     private static final Map<Class<? extends ConfigurationProvider>, ConfigurationProvider> providers = new HashMap<>();
+    // IvanCord start
+    private static JsonConfiguration providerPrettyJson;
+    private static JsonConfiguration providerNonPrettyJson;
+    // IvanCord end
 
     static
     {
         providers.put( YamlConfiguration.class, new YamlConfiguration() );
+        // IvanCord start
+        ConfigurationProvider.providerPrettyJson = new JsonConfiguration( true );
+        ConfigurationProvider.providerNonPrettyJson = new JsonConfiguration( false );
+        // IvanCord end
     }
 
     public static ConfigurationProvider getProvider(Class<? extends ConfigurationProvider> provider)
     {
+        // IvanCord start
+        if ( provider.isAssignableFrom( JsonConfiguration.class ) )
+        {
+            return getJsonConfigurationProvider( true );
+        }
+        // IvanCord end
         return providers.get( provider );
     }
 
@@ -37,6 +51,17 @@ public abstract class ConfigurationProvider
         }
         providers.remove( provider );
     }
+
+    /**
+     * Gets a json configuration provider.
+     *
+     * @param prettyPrinting should the typen json when saving be readable for humans, or no?
+     * @return json configuration provider
+     */
+    public static ConfigurationProvider getJsonConfigurationProvider(boolean prettyPrinting)
+    {
+        return prettyPrinting ? providerPrettyJson : providerNonPrettyJson;
+    }
     // IvanCord end
 
     /*------------------------------------------------------------------------*/
diff --git a/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java b/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..22192405c82d8eb833fb637d85c03272b15431f6
--- /dev/null
+++ b/config/src/main/java/net/md_5/bungee/config/JsonConfiguration.java
@@ -0,0 +1,117 @@
+// IvanCord start
+package net.md_5.bungee.config;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import com.google.common.base.Charsets;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import com.mrivanplays.ivancord.config.MapSerializer;
+
+public class JsonConfiguration extends ConfigurationProvider
+{
+
+    private Gson gson;
+    private Type mapType;
+
+    public JsonConfiguration(boolean prettyPrinting)
+    {
+        this.mapType = new TypeToken<Map<String, Object>>(){}.getType();
+        if ( prettyPrinting )
+        {
+            gson = new GsonBuilder().registerTypeAdapter( mapType, new MapSerializer() ).setPrettyPrinting().create();
+        } else
+        {
+            gson = new GsonBuilder().registerTypeAdapter( mapType, new MapSerializer() ).create();
+        }
+    }
+
+    @Override
+    public void save(Configuration config, File file) throws IOException
+    {
+        try ( Writer writer = new OutputStreamWriter( new FileOutputStream( file ), Charsets.UTF_8 ) )
+        {
+            save( config, writer );
+        }
+    }
+
+    @Override
+    public void save(Configuration config, Writer writer)
+    {
+        gson.toJson( config.self, mapType, writer );
+    }
+
+    @Override
+    public Configuration load(File file) throws IOException
+    {
+        return load( file, null );
+    }
+
+    @Override
+    public Configuration load(File file, Configuration defaults) throws IOException
+    {
+        try ( FileReader reader = new FileReader( file ) )
+        {
+            return load( reader, defaults );
+        }
+    }
+
+    @Override
+    public Configuration load(Reader reader)
+    {
+        return load( reader, null );
+    }
+
+    @Override
+    public Configuration load(Reader reader, Configuration defaults)
+    {
+        Map<String, Object> map = gson.fromJson( reader, mapType );
+        if ( map == null )
+        {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration( map, defaults );
+    }
+
+    @Override
+    public Configuration load(InputStream is)
+    {
+        return load( is, null );
+    }
+
+    @Override
+    public Configuration load(InputStream is, Configuration defaults)
+    {
+        return load( new InputStreamReader( is ), defaults );
+    }
+
+    @Override
+    public Configuration load(String string)
+    {
+        return load( string, null );
+    }
+
+    @Override
+    public Configuration load(String string, Configuration defaults)
+    {
+        Map<String, Object> map = gson.fromJson( string, mapType );
+        if ( map == null )
+        {
+            map = new LinkedHashMap<>();
+        }
+        return new Configuration( map, defaults );
+    }
+}
+// IvanCord end
